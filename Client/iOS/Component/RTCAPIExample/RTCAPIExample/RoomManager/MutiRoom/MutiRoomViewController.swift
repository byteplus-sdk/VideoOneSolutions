/**
* Function name: BytePlusRTC multi-room
* Function brief description: You may need to have the same user join multiple RTCs
* Room, listen/watch audio & video in different rooms at the same time, and publish audio & video in one of the rooms
* Reminder:
* 1. To demonstrate, all functional tokens are generated by the client side TokenGenerator class, please depend on the specific situation when actually accessing
* 2. This demo demonstration function shows only 3 video windows, the first line shows the local capture screen, and the second line shows room1 respectively.
* Remote user and room2 remote user
* Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-196844
*/

import Foundation
import SnapKit
import BytePlusRTC

class MutiRoomViewController: BaseViewController, ByteRTCVideoDelegate, ByteRTCRoomDelegate {
    
    var rtcVideo: ByteRTCVideo?
    var rtcRoom1: ByteRTCRoom?
    var rtcRoom2: ByteRTCRoom?
    var users : Array = Array<ByteRTCRemoteStreamKey>()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.createUI()
        self.buildRTCEngine()
    }
    
    deinit {
        self.rtcRoom1?.leaveRoom()
        self.rtcRoom1?.destroy()
        self.rtcRoom1 = nil
        
        self.rtcRoom2?.leaveRoom()
        self.rtcRoom2?.destroy()
        self.rtcRoom2 = nil
        
        ByteRTCVideo.destroyRTCVideo()
        self.rtcVideo = nil
    }
    
    // MARK: Private method
    
    @objc func joinRoom1()  {
        let roomId = self.roomTextField1.text ?? ""
        let userId = self.userTextField1.text ?? ""
        
        var vaild = checkValid(roomId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_roomid1_false"))
            return
        }
        
        vaild = checkValid(userId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_userid1_false"))
            return
        }
        
        joinButton1.isSelected = !joinButton1.isSelected
        
        if joinButton1.isSelected {
            generatorToken(roomId: roomId, userId: userId) { [weak self] token in
                self?.joinButton1.setTitle(LocalizedString("button_leave_room1"), for: .normal)
                
                // Join room
                self?.rtcRoom1 = self?.rtcVideo?.createRTCRoom(roomId)
                self?.rtcRoom1?.delegate = self
                
                let userInfo = ByteRTCUserInfo.init()
                userInfo.userId = userId
                
                // Automatic publish and subscribe streams
                let roomCfg = ByteRTCRoomConfig.init()
                roomCfg.isAutoPublish = true
                roomCfg.isAutoSubscribeAudio = true
                roomCfg.isAutoSubscribeVideo = true
                
                self?.rtcRoom1?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
            }
        } else {
            joinButton1.setTitle(LocalizedString("button_join_room1"), for: .normal)
            self.rtcRoom1?.leaveRoom()
            self.firstRemoteView.userId = ""
        }
        
    }
    
    @objc func joinRoom2() -> Void {
        let roomId = self.roomTextField2.text ?? ""
        let userId = self.userTextField2.text ?? ""
        
        var vaild = checkValid(roomId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_roomid2_false"))
            return
        }
        
        vaild = checkValid(userId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_userid2_false"))
            return
        }
        
        joinButton2.isSelected = !joinButton2.isSelected
        
        if joinButton2.isSelected {
            generatorToken(roomId: roomId, userId: userId) { [weak self] token in
                self?.joinButton2.setTitle(LocalizedString("button_leave_room2"), for: .normal)
                
                // Join room
                self?.rtcRoom2 = self?.rtcVideo?.createRTCRoom(roomId)
                self?.rtcRoom2?.delegate = self
                
                let userInfo = ByteRTCUserInfo.init()
                userInfo.userId = userId
                
                // Room 2 does not automatically publish, it can only be published in one room
                let roomCfg = ByteRTCRoomConfig.init()
                roomCfg.isAutoPublish = false
                roomCfg.isAutoSubscribeAudio = true
                roomCfg.isAutoSubscribeVideo = true
                
                self?.rtcRoom2?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
            }
        }
        else {
            joinButton2.setTitle(LocalizedString("button_join_room2"), for: .normal)
            self.rtcRoom2?.leaveRoom()
            self.secondRemoteView.userId = ""
        }
        
    }
    
    func buildRTCEngine() {
        // Create engine
        self.rtcVideo = ByteRTCVideo.createRTCVideo(kAppID, delegate: self, parameters: [:])
        
        // Enable local audio and video collection
        self.rtcVideo?.startVideoCapture()
        self.rtcVideo?.startAudioCapture()
        
        // Enable local rendering
        self.bindLocalRenderView()
    }
    
    func bindLocalRenderView() {
        // Set local rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = self.localView.videoView
        canvas.renderMode = .hidden
        self.localView.userId = userTextField1.text ?? ""
        
        self.rtcVideo?.setLocalVideoCanvas(.main, withCanvas: canvas);
    }
    
    func bindRemoteRenderView(view: UserVideoView, roomId: String, userId: String) {
        // Set the remote user video rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = view.videoView
        canvas.renderMode = .hidden
        view.userId = userId
        
        let streamKey = ByteRTCRemoteStreamKey.init()
        streamKey.userId = userId
        streamKey.roomId = roomId
        streamKey.streamIndex = .main
        
        self.rtcVideo?.setRemoteVideoCanvas(streamKey, withCanvas: canvas)
    }
    
    func updateRenderView() {
        // Get the first user of room1 and the first user of room2
        var remoteUser1:ByteRTCRemoteStreamKey?
        var remoteUser2:ByteRTCRemoteStreamKey?
        
        for streamKey in self.users {
            if remoteUser1 == nil && streamKey.roomId == self.roomTextField1.text {
                remoteUser1 = streamKey
            } else if remoteUser2 == nil && streamKey.roomId ==  self.roomTextField2.text {
                remoteUser2 = streamKey
            }
        }
        
        if (remoteUser1 != nil) {
            self.bindRemoteRenderView(view: self.firstRemoteView,roomId: (remoteUser1?.roomId)!,userId: (remoteUser1?.userId)!)
        }
        
        if (remoteUser2 != nil) {
            self.bindRemoteRenderView(view: self.secondRemoteView,roomId: (remoteUser2?.roomId)!,userId: (remoteUser2?.userId)!)
        }
    }
    
    func createUI() -> Void {
        view.addSubview(containerView)
        self.containerView.addSubview(localView)
        self.containerView.addSubview(firstRemoteView)
        self.containerView.addSubview(secondRemoteView)
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(self.topView.snp.bottom)
            make.left.right.equalTo(self.view)
        }
        
        self.localView.snp.makeConstraints { make in
            make.left.top.equalTo(self.containerView)
            make.width.equalTo(self.containerView)
            make.height.equalTo(self.containerView).multipliedBy(0.5)
        }
        
        self.firstRemoteView.snp.makeConstraints { make in
            make.left.bottom.equalTo(self.containerView)
            make.width.height.equalTo(self.containerView).multipliedBy(0.5)
        }
        
        self.secondRemoteView.snp.makeConstraints { make in
            make.right.bottom.equalTo(self.containerView)
            make.width.height.equalTo(self.containerView).multipliedBy(0.5)
        }
        
        view.addSubview(roomLabel1)
        view.addSubview(roomTextField1)
        view.addSubview(userLabel1)
        view.addSubview(userTextField1)
        view.addSubview(joinButton1)
        view.addSubview(publishLabel)
        
        roomLabel1.snp.makeConstraints { make in
            make.top.equalTo(self.containerView.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
        }
        
        roomTextField1.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel1)
            make.left.equalTo(roomLabel1.snp.right).offset(10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        userLabel1.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel1)
        }
        
        userTextField1.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel1)
            make.left.equalTo(userLabel1.snp.right).offset(10)
            make.right.equalTo(self.view).offset(-10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        publishLabel.snp.makeConstraints { make in
            make.top.equalTo(roomLabel1.snp.bottom).offset(10)
            make.left.equalTo(roomLabel1)
        }
        
        joinButton1.snp.makeConstraints { make in
            make.top.equalTo(publishLabel.snp.bottom).offset(10)
            make.left.equalTo(publishLabel)
            make.right.equalTo(self.view).offset(-10)
            make.height.equalTo(36)
        }
        
        view.addSubview(roomLabel2)
        view.addSubview(roomTextField2)
        view.addSubview(userLabel2)
        view.addSubview(userTextField2)
        view.addSubview(joinButton2)
        
        roomLabel2.snp.makeConstraints { make in
            make.top.equalTo(joinButton1.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        roomTextField2.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel2)
            make.left.equalTo(roomLabel2.snp.right).offset(10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        userLabel2.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel2)
        }
        
        userTextField2.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel2)
            make.left.equalTo(userLabel2.snp.right).offset(10)
            make.right.equalTo(userTextField1)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        joinButton2.snp.makeConstraints { make in
            make.top.equalTo(roomLabel2.snp.bottom).offset(10)
            make.bottom.equalToSuperview().offset(-getSafeAreaInsets().bottom)
            make.left.right.equalTo(joinButton1)
            make.height.equalTo(36)
        }
    }
    
    // MARK: Lazy laod
    lazy var roomLabel1: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_room1")
        return label
    }()
    
    lazy var roomTextField1: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var userLabel1: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_user1")
        return label
    }()
    
    lazy var userTextField1: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var joinButton1: UIButton = {
        let button = BaseButton.init()
        button.setTitle(LocalizedString("button_join_room1"), for: .normal)
        button.addTarget(self, action: #selector(joinRoom1), for: .touchUpInside)
        return button
    }()
    
    lazy var publishLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_room1_publish")
        return label
    }()
    
    lazy var roomLabel2: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_room2")
        return label
    }()
    
    lazy var roomTextField2: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var userLabel2: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_user2")
        return label
    }()
    
    lazy var userTextField2: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var joinButton2: UIButton = {
        let button = BaseButton.init()
        button.setTitle(LocalizedString("button_join_room2"), for: .normal)
        button.addTarget(self, action: #selector(joinRoom2), for: .touchUpInside)
        return button
    }()
    
    lazy var containerView: UIView = {
        let view = UIView.init()
        view.backgroundColor = .groupTableViewBackground
        return view
    }()
    
    lazy var localView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    lazy var firstRemoteView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    lazy var secondRemoteView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    // MARK: ByteRTCVideoDelegate & ByteRTCRoomDelegate
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onRoomStateChanged roomId: String, withUid uid: String, state: Int, extraInfo: String) {
        ToastComponents.shared.show(withMessage: "onRoomStateChanged uid: \(uid) state:\(state)")
        
    }
    
    // Remote user publishing stream
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserPublishStream userId: String, type: ByteRTCMediaStreamType) {
        ToastComponents.shared.show(withMessage: "onUserPublishStream uid: \(userId)")
        
        if type == .video || type == .both {
            
            let streamKey = ByteRTCRemoteStreamKey.init()
            streamKey.userId = userId
            streamKey.roomId = rtcRoom.getId();
            streamKey.streamIndex = .main
            
            self.users.append(streamKey)
            
            DispatchQueue.main.async {
                self.updateRenderView()
            }
        }
    }
    
    // Remote user cancels publishing flow
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserUnpublishStream userId: String, type: ByteRTCMediaStreamType, reason: ByteRTCStreamRemoveReason) {
        ToastComponents.shared.show(withMessage: "onUserUnpublishStream uid: \(userId)")
        
        if type == .video || type == .both {
            
            // Remove from self.users
            var itemsToRemove: [ByteRTCRemoteStreamKey] = []
            
            for streamKey in self.users {
                if streamKey.userId == userId {
                    itemsToRemove.append(streamKey)
                }
            }
            
            for item in itemsToRemove {
                if let index = self.users.firstIndex(of: item) {
                    self.users.remove(at: index)
                }
            }
            
            DispatchQueue.main.async {
                for videoView in self.containerView.subviews {
                    if let view = videoView as? UserVideoView {
                        let userId = view.userId
                        
                        if userId == userId {
                            view.userId = ""
                        }
                    }
                }
            }
            
            DispatchQueue.main.async {
                self.updateRenderView()
            }
        }
    }
    
    // Remote users join the room
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserJoined userInfo: ByteRTCUserInfo, elapsed: Int) {
        ToastComponents.shared.show(withMessage: "onUserJoined uid: \(userInfo.userId)")
        
    }
    
    // The remote user leaves the room
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserLeave uid: String, reason: ByteRTCUserOfflineReason) {
        ToastComponents.shared.show(withMessage: "onUserLeave uid: \(uid)")
        
    }
    
    // Token is about to expire
    func onTokenWillExpire(_ rtcRoom: ByteRTCRoom) {
        ToastComponents.shared.show(withMessage: LocalizedString("toast_will_expire"))
    }
}
