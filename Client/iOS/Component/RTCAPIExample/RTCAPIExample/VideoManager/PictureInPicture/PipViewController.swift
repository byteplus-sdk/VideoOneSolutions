/**
* Function name: BytePlusRTC picture-in-picture
* Simple description of the function: realize the picture-in-picture function
* Reminder:
* 1. To demonstrate, all functional tokens are generated by the client side TokenGenerator class, please depend on the specific situation when actually accessing
* Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-1178325
*/

import UIKit
import AVKit
import SnapKit
import BytePlusRTC

@objc(PipViewController)
class PipViewController: BaseViewController, ByteRTCVideoDelegate, ByteRTCRoomDelegate, AVPictureInPictureControllerDelegate {
    
    var rtcVideo: ByteRTCVideo?
    var rtcRoom: ByteRTCRoom?
    var users : Array = Array<ByteRTCRemoteStreamKey>()
    var pipVC: AVPictureInPictureController?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.createUI()
        self.buildRTCEngine()
        self.setupPipController(with: self.customRenderView)
    }
    
    deinit {
        self.rtcRoom?.leaveRoom()
        self.rtcRoom?.destroy()
        self.rtcRoom = nil
        
        ByteRTCVideo.destroyRTCVideo()
        self.rtcVideo = nil
    }
    
    // MARK: Private method
    
    @objc func joinRoom()  {
        let roomId = self.roomSettingItem.text ?? ""
        let userId = self.userSettingItem.text ?? ""
        
        var vaild = checkValid(roomId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        vaild = checkValid(userId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        joinButton.isSelected = !joinButton.isSelected
        
        if joinButton.isSelected {
            generateToken(roomId: roomId, userId: userId) { [weak self] token in
                self?.joinButton.setTitle(LocalizedString("button_leave_room"), for: .normal)
                // Join room
                self?.rtcRoom = self?.rtcVideo?.createRTCRoom(roomId)
                self?.rtcRoom?.delegate = self
                
                let userInfo = ByteRTCUserInfo.init()
                userInfo.userId = userId
                
                let roomCfg = ByteRTCRoomConfig.init()
                roomCfg.isAutoPublish = true
                roomCfg.isAutoSubscribeAudio = true
                roomCfg.isAutoSubscribeVideo = true
                
                self?.rtcRoom?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
            }
        } else {
            self.joinButton.setTitle(LocalizedString("button_join_room"), for: .normal)
            self.rtcRoom?.leaveRoom()
        }
    }
    
    @objc func startPip()  {
        if #available(iOS 16, *) {
            if self.pipVC!.isPictureInPictureActive {
                self.pipVC!.stopPictureInPicture()
                pipButton.setTitle(LocalizedString("button_start_pip"), for: .normal)
            } else {
                self.pipVC!.startPictureInPicture()
                pipButton.setTitle(LocalizedString("button_stop_pip"), for: .normal)
            }
        } else {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_pip_system_false"))
        }
    }
    
    func buildRTCEngine() {
        // Create engine
        self.rtcVideo = ByteRTCVideo.createRTCVideo(rtcAppId(), delegate: self, parameters: [:])
        self.rtcVideo?.setBusinessId("pip")
        
        // Enable local audio and video collection
        self.rtcVideo?.startVideoCapture()
        self.rtcVideo?.startAudioCapture()
        self.bindLocalRenderView()
    }
    
    func bindLocalRenderView() {
        // Set local rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = self.localView.videoView
        canvas.renderMode = .hidden
        self.localView.userId = userSettingItem.text ?? ""
        self.rtcVideo?.setLocalVideoCanvas(.indexMain, withCanvas: canvas);
    }
    
    func updateRenderView() {
        // Get the first user of room1 and the first user of room2
        var remoteUser:ByteRTCRemoteStreamKey?
        
        for streamKey in self.users {
            if remoteUser == nil && streamKey.roomId == self.roomSettingItem.text {
                remoteUser = streamKey
            }
        }
        
        if (remoteUser != nil) {
            let roomId = remoteUser!.roomId!
            let userId = remoteUser!.userId!
            
            self.bindRemoteRenderView(view: self.customRenderView, roomId: roomId, userId: userId)
            self.remoteUserIdLabel.text = "\(roomId):\(userId)"
        } else {
            self.remoteUserIdLabel.text = ""
        }
    }
    
    func bindRemoteRenderView(view: CustomVideoRenderView, roomId: String, userId: String) {
        let streamKey = ByteRTCRemoteStreamKey.init()
        streamKey.userId = userId
        streamKey.roomId = roomId;
        streamKey.streamIndex = .indexMain
        
        // Use external rendering
        // The picture-in-picture function relies on the external rendering function. Using internal rendering will cause a black screen.
        self.rtcVideo?.setRemoteVideoSink(streamKey, withSink: self.customRenderView, withPixelFormat: .original)
    }
    
    func createUI() -> Void {
        view.addSubview(containerView)
        self.containerView.addSubview(localView)
        self.containerView.addSubview(customRenderView)
        self.containerView.addSubview(remoteUserIdLabel)
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(topView.snp.bottom)
            make.height.equalTo(containerView.snp.width)
            make.left.right.equalTo(self.view)
        }
        
        self.localView.snp.makeConstraints { make in
            make.left.top.equalTo(self.containerView)
            make.height.equalTo(self.containerView)
            make.width.equalTo(self.containerView).multipliedBy(0.5)
        }
        
        self.customRenderView.snp.makeConstraints { make in
            make.top.right.equalTo(self.containerView)
            make.bottom.equalTo(self.containerView).offset(-30)
            make.width.equalTo(self.containerView).multipliedBy(0.5)
        }
        
        self.remoteUserIdLabel.snp.makeConstraints { make in
            make.left.equalTo(localView.snp.right)
            make.right.bottom.equalTo(self.containerView)
            make.height.equalTo(30)
        }
        
        view.addSubview(roomSettingItem)
        view.addSubview(userSettingItem)
        view.addSubview(joinButton)
        view.addSubview(pipButton)
        
        roomSettingItem.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.height.equalTo(30)
        }
        
        userSettingItem.snp.makeConstraints { make in
            make.centerY.equalTo(roomSettingItem)
            make.left.equalTo(roomSettingItem.snp.right).offset(20)
            make.right.equalToSuperview().offset(-10)
            make.width.height.equalTo(roomSettingItem)
        }
        
        joinButton.snp.makeConstraints { make in
            make.top.equalTo(roomSettingItem.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(36)
        }
        
        pipButton.snp.makeConstraints { make in
            make.top.equalTo(joinButton.snp.bottom).offset(10)
            make.left.right.width.height.equalTo(joinButton)
        }
    }
    
    func setupPipController(with sourceView: UIView) {
        if #available(iOS 16, *) {
            let callViewController = AVPictureInPictureVideoCallViewController()
            callViewController.preferredContentSize = CGSize(width: 360, height: 640)
            callViewController.view.backgroundColor = UIColor.clear
            
            let source = AVPictureInPictureController.ContentSource(activeVideoCallSourceView: sourceView, contentViewController: callViewController)
            
            let pipVC = AVPictureInPictureController(contentSource: source)
            pipVC.canStartPictureInPictureAutomaticallyFromInline = true
            pipVC.delegate = self
            self.pipVC = pipVC
        } else {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_pip_system_false"))
        }
    }
    
    // MARK: Lazy laod
    lazy var roomSettingItem: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("hint_room_id")
        return settingView
    }()
    
    lazy var userSettingItem: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("hint_user_id")
        return settingView
    }()
    
    lazy var joinButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_join_room"), for: .normal)
        button.addTarget(self, action: #selector(joinRoom), for: .touchUpInside)
        return button
    }()
    
    lazy var pipButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_start_pip"), for: .normal)
        button.addTarget(self, action: #selector(startPip), for: .touchUpInside)
        return button
    }()
    
    lazy var remoteUserIdLabel: UILabel = {
        let label = UILabel.init()
        label.textAlignment = .center
        return label
    }()
    
    lazy var containerView: UIView = {
        let view = UIView.init()
        view.backgroundColor = .groupTableViewBackground
        return view
    }()
    
    lazy var localView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    lazy var customRenderView: CustomVideoRenderView = {
        let view = CustomVideoRenderView.init(frame: CGRectZero)
        return view
    }()
    
    // MARK: AVPictureInPictureControllerDelegate
    func pictureInPictureControllerWillStartPictureInPicture(_ pictureInPictureController: AVPictureInPictureController) {
        // Picture-in-picture is about to begin
        ToastComponents.shared.show(withMessage: "pictureInPictureControllerWillStart")
    }
    
    func pictureInPictureControllerDidStartPictureInPicture(_ pictureInPictureController: AVPictureInPictureController) {
        var remoteUser:ByteRTCRemoteStreamKey?
        for streamKey in self.users {
            if remoteUser == nil && streamKey.roomId == self.roomSettingItem.text {
                remoteUser = streamKey
            }
        }
        
        if ((remoteUser) != nil) {
            ToastComponents.shared.show(withMessage: "pictureInPictureControllerDidStart")
        } else {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_pip_no_user_fale"))
        }
        
        // Picture-in-picture has started
        pipButton.setTitle(LocalizedString("button_stop_pip"), for: .normal)
        
        if #available(iOS 16.0, *) {
            if let vc = pictureInPictureController.contentSource?.activeVideoCallContentViewController {
                vc.view.addSubview(self.customRenderView)
                self.customRenderView.snp.remakeConstraints() { make in
                    make.edges.equalTo(vc.view)
                }
            }
        }
    }
    
    func pictureInPictureController(_ pictureInPictureController: AVPictureInPictureController, failedToStartPictureInPictureWithError error: Error) {
        // Picture-in-picture starts to fail
        ToastComponents.shared.show(withMessage: "failedToStartPictureInPicture")
    }
    
    func pictureInPictureControllerWillStopPictureInPicture(_ pictureInPictureController: AVPictureInPictureController) {
        // Picture-in-picture is about to stop
        ToastComponents.shared.show(withMessage: "pictureInPictureControllerWillStop")
    }
    
    func pictureInPictureControllerDidStopPictureInPicture(_ pictureInPictureController: AVPictureInPictureController) {
        ToastComponents.shared.show(withMessage: "pictureInPictureControllerDidStop")
        
        // Picture-in-picture has stopped
        pipButton.setTitle(LocalizedString("button_start_pip"), for: .normal)
        
        self.containerView.addSubview(customRenderView)
        self.customRenderView.snp.remakeConstraints() { make in
            make.top.right.equalTo(self.containerView)
            make.bottom.equalTo(self.containerView).offset(-30)
            make.width.equalTo(self.containerView).multipliedBy(0.5)
        }
    }
    
    // MARK: ByteRTCVideoDelegate & ByteRTCRoomDelegate
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onRoomStateChanged roomId: String, withUid uid: String, state: Int, extraInfo: String) {
        ToastComponents.shared.show(withMessage: "onRoomStateChanged uid: \(uid) state:\(state)")
        
    }
    
    // Remote user publishing stream
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserPublishStream userId: String, type: ByteRTCMediaStreamType) {
        ToastComponents.shared.show(withMessage: "onUserPublishStream uid: \(userId)")
        
        if type == .video || type == .both {
            
            let streamKey = ByteRTCRemoteStreamKey.init()
            streamKey.userId = userId
            streamKey.roomId = rtcRoom.getId();
            streamKey.streamIndex = .indexMain
            
            self.users.append(streamKey)
            
            DispatchQueue.main.async {
                self.updateRenderView()
            }
        }
    }
    
     // Remote user cancels publishing flow
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserUnpublishStream userId: String, type: ByteRTCMediaStreamType, reason: ByteRTCStreamRemoveReason) {
        ToastComponents.shared.show(withMessage: "onUserUnpublishStream uid: \(userId)")
        
        if type == .video || type == .both {
            
            // Remove from self.users
            var itemsToRemove: [ByteRTCRemoteStreamKey] = []
            
            for streamKey in self.users {
                if streamKey.userId == userId {
                    itemsToRemove.append(streamKey)
                }
            }
            
            for item in itemsToRemove {
                if let index = self.users.firstIndex(of: item) {
                    self.users.remove(at: index)
                }
            }
            
            DispatchQueue.main.async {
                for videoView in self.containerView.subviews {
                    if let view = videoView as? UserVideoView {
                        let userId = view.userId
                        
                        if userId == userId {
                            view.userId = ""
                        }
                    }
                }
            }
            
            DispatchQueue.main.async {
                self.updateRenderView()
            }
        }
    }
    
    
    // Remote users join the room
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserJoined userInfo: ByteRTCUserInfo, elapsed: Int) {
        ToastComponents.shared.show(withMessage: "onUserJoined uid: \(userInfo.userId)")
        
    }
    
    // The remote user leaves the room
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserLeave uid: String, reason: ByteRTCUserOfflineReason) {
        ToastComponents.shared.show(withMessage: "onUserLeave uid: \(uid)")
        
    }
}

