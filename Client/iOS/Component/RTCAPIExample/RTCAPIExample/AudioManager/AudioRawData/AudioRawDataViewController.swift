/**
* Function name: BytePlusRTC raw audio data
* Function brief description: Get the original audio data of the specified type by registering the callback interface
* Reminder:
* 1. ByteRTCAudioFrameObserver callback data does not support modification, modification is invalid
If you want to process audio before sending it, use the Custom Audio Processing interface.
* 2. To demonstrate, all functional tokens are generated by the client side TokenGenerator class, please depend on the specific situation when actually accessing
* Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-1178324
*/


import UIKit
import SnapKit
import BytePlusRTC

@objc(AudioRawDataViewController)
class AudioRawDataViewController: BaseViewController, ByteRTCVideoDelegate, ByteRTCRoomDelegate,ByteRTCAudioFrameObserver {
    
    var rtcVideo: ByteRTCVideo?
    var rtcRoom1: ByteRTCRoom?
    var lastLogTime: Date?

    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.createUI()
        self.buildRTCEngine()
        self.bindLocalRenderView()
        self.buildActions()
    }
    
    deinit {
        self.rtcVideo?.registerAudioFrameObserver(nil)

        self.rtcRoom1?.leaveRoom()
        self.rtcRoom1?.destroy()
        self.rtcRoom1 = nil
        
        ByteRTCVideo.destroyRTCVideo()
        self.rtcVideo = nil
    }
    
    // MARK: Private method
    
    @objc func joinRoom()  {
        let roomId = self.roomTextField.text ?? ""
        let userId = self.userTextField.text ?? ""
        
        var vaild = checkValid(roomId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        vaild = checkValid(userId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        joinButton.isSelected = !joinButton.isSelected
        
        if joinButton.isSelected {
            generatorToken(roomId: roomId, userId: userId) { [weak self] token in
                self?.joinButton.setTitle(LocalizedString("button_leave_room"), for: .normal)
                
                // Join room
                self?.rtcRoom1 = self?.rtcVideo?.createRTCRoom(roomId)
                self?.rtcRoom1?.delegate = self
                
                let userInfo = ByteRTCUserInfo.init()
                userInfo.userId = userId
                
                let roomCfg = ByteRTCRoomConfig.init()
                roomCfg.isAutoPublish = true
                roomCfg.isAutoSubscribeAudio = true
                roomCfg.isAutoSubscribeVideo = true
                
                self?.rtcRoom1?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
            }
        }
        else {
            self.joinButton.setTitle(LocalizedString("button_join_room"), for: .normal)
            self.rtcRoom1?.leaveRoom()
        }
    }
    
    func buildRTCEngine() {
        // Create engine
        self.rtcVideo = ByteRTCVideo.createRTCVideo(kAppID, delegate: self, parameters: [:])
        
        // Enable local audio and video collection
        self.rtcVideo?.startVideoCapture()
        self.rtcVideo?.startAudioCapture()
        
        self.bindLocalRenderView()
    }
    
    func buildActions() {
        self.rtcVideo!.registerAudioFrameObserver(self)

        // Local recording
        self.recordSwitch.switchValueChanged = { [weak self] isOn in
            if isOn {
                let audioFormat = ByteRTCAudioFormat.init()
                audioFormat.sampleRate = .rate44100
                audioFormat.channel = .stereo
                audioFormat.samplesPerCall = 0

                self?.rtcVideo?.enableAudioFrameCallback(.record, format: audioFormat)
            } else {
                self?.rtcVideo?.disableAudioFrameCallback(.record)
            }
        }
        
        // All remote mixes
        self.playbackSwitch.switchValueChanged = { [weak self] isOn in
            if isOn {
                let palyoutFormat = ByteRTCAudioFormat.init()
                palyoutFormat.sampleRate = .rate44100
                palyoutFormat.channel = .stereo
                palyoutFormat.samplesPerCall = 0

                self?.rtcVideo?.enableAudioFrameCallback(.playback, format: palyoutFormat)
            } else {
                self?.rtcVideo?.disableAudioFrameCallback(.playback)
            }
        }
        
        // Local + remote mix
        self.mixedSwitch.switchValueChanged = { [weak self] isOn in
            if isOn {
                let mixedFormat = ByteRTCAudioFormat.init()
                mixedFormat.sampleRate = .rate44100
                mixedFormat.channel = .stereo
                mixedFormat.samplesPerCall = 0

                self?.rtcVideo?.enableAudioFrameCallback(.mixed, format: mixedFormat)
            } else {
                self?.rtcVideo?.disableAudioFrameCallback(.mixed)
            }
        }
        
        // Single remote
        self.remoteUserSwitch.switchValueChanged = { [weak self] isOn in
            if isOn {
                let remoteFormat = ByteRTCAudioFormat.init()
                remoteFormat.sampleRate = .rateAuto
                remoteFormat.channel = .auto
                remoteFormat.samplesPerCall = 0

                self?.rtcVideo?.enableAudioFrameCallback(.remoteUser, format: remoteFormat)
            } else {
                self?.rtcVideo?.disableAudioFrameCallback(.remoteUser)
            }
        }
        
    }
    
    func bindLocalRenderView() {
        // Set local rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = self.localView.videoView
        canvas.renderMode = .hidden
        self.localView.userId = userTextField.text ?? ""
        
        self.rtcVideo?.setLocalVideoCanvas(.main, withCanvas: canvas);
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.view.endEditing(true)
    }
    
    func createUI() -> Void {
        // Add view
        view.addSubview(containerView)
        self.containerView.addSubview(localView)
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(self.topView.snp.bottom)
            make.left.right.equalTo(self.view)
        }
        
        self.localView.snp.makeConstraints { make in
            make.left.top.equalTo(self.containerView)
            make.width.height.equalTo(self.containerView)
        }
        
        view.addSubview(roomLabel)
        view.addSubview(roomTextField)
        view.addSubview(userLabel)
        view.addSubview(userTextField)
        view.addSubview(joinButton)
        
        roomLabel.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        roomTextField.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel)
            make.left.equalTo(roomLabel.snp.right).offset(10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        userLabel.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel)
        }
        
        userTextField.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel)
            make.left.equalTo(userLabel.snp.right).offset(10)
            make.right.equalTo(view).offset(-10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        joinButton.snp.makeConstraints { make in
            make.top.equalTo(roomLabel.snp.bottom).offset(20)
            make.left.equalTo(roomLabel)
            make.right.equalTo(view).offset(-10)
            make.height.equalTo(36)
        }
        
        view.addSubview(recordSwitch)
        view.addSubview(playbackSwitch)
        view.addSubview(mixedSwitch)
        view.addSubview(remoteUserSwitch)

        recordSwitch.snp.makeConstraints { make in
            make.top.equalTo(joinButton.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
        }
        
        playbackSwitch.snp.makeConstraints { make in
            make.top.equalTo(recordSwitch.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
        }
        
        mixedSwitch.snp.makeConstraints { make in
            make.top.equalTo(playbackSwitch.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
        }
        
        remoteUserSwitch.snp.makeConstraints { make in
            make.top.equalTo(mixedSwitch.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.bottom.equalTo(self.view).offset(-getSafeAreaInsets().bottom)
        }
    }
    
    // MARK: Lazy laod
    lazy var roomLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("hint_room_id")
        return label
    }()
    
    lazy var roomTextField: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var userLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("hint_user_id")
        return label
    }()
    
    lazy var userTextField: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var joinButton: UIButton = {
        let button = BaseButton.init()
        button.setTitle(LocalizedString("button_join_room"), for: .normal)
        button.addTarget(self, action: #selector(joinRoom), for: .touchUpInside)
        return button
    }()
    
    lazy var recordSwitch: SwitchSettingView = {
        let switchView = SwitchSettingView.init(text: LocalizedString("label_callback_record"))
        return switchView
    }()
    
    lazy var playbackSwitch: SwitchSettingView = {
        let switchView = SwitchSettingView.init(text: LocalizedString("label_callback_playback"))
        return switchView
    }()
    
    lazy var mixedSwitch: SwitchSettingView = {
        let switchView = SwitchSettingView.init(text: LocalizedString("label_callback_mixed"))
        return switchView
    }()
    
    lazy var remoteUserSwitch: SwitchSettingView = {
        let switchView = SwitchSettingView.init(text: LocalizedString("label_callback_remote_user"))
        return switchView
    }()
    
    lazy var containerView: UIView = {
        let view = UIView.init()
        view.backgroundColor = .groupTableViewBackground
        return view
    }()
    
    lazy var localView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    // MARK: ByteRTCVideoDelegate & ByteRTCRoomDelegate
    // Room entry status
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onRoomStateChanged roomId: String, withUid uid: String, state: Int, extraInfo: String) {
        ToastComponents.shared.show(withMessage: "onRoomStateChanged uid: \(uid) state:\(state)")
        
    }
    
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserJoined userInfo: ByteRTCUserInfo, elapsed: Int) {
        ToastComponents.shared.show(withMessage: "onUserJoined uid: \(userInfo.userId)")
    }
    
    // Remote user publishing stream
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserPublishStream userId: String, type: ByteRTCMediaStreamType) {
        ToastComponents.shared.show(withMessage: "onUserPublishStream uid: \(userId)")
        
    }
    
    // Remote user cancels publishing flow
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserUnpublishStream userId: String, type: ByteRTCMediaStreamType, reason: ByteRTCStreamRemoveReason) {
        ToastComponents.shared.show(withMessage: "onUserUnpublishStream uid: \(userId)")
        
    }
    
    // MARK: ByteRTCAudioFrameObserver
    func onRecord(_ audioFrame: ByteRTCAudioFrame) {
        print("onRecord audioFrame")
        
        if checkLogTimeVaild() {
            ToastComponents.shared.show(withMessage: "onRecord audioFrame")
        }
    }
    
    func onPlaybackAudioFrame(_ audioFrame: ByteRTCAudioFrame) {
        print("onPlaybackAudioFrame")
        
        if checkLogTimeVaild() {
            ToastComponents.shared.show(withMessage: "onPlaybackAudioFrame")
        }
    }
    
    func onMixedAudioFrame(_ audioFrame: ByteRTCAudioFrame) {
        print("onMixedAudioFrame")
        
        if checkLogTimeVaild() {
            ToastComponents.shared.show(withMessage: "onMixedAudioFrame")
        }
    }
    
    func onRemoteUserAudioFrame(_ streamKey: ByteRTCRemoteStreamKey, audioFrame: ByteRTCAudioFrame) {
        print("onRemoteUserAudioFrame")
        
        if checkLogTimeVaild() {
            ToastComponents.shared.show(withMessage: "onRemoteUserAudioFrame")
        }
    }
    
    // Check whether it is more than 5 seconds since the last log
    func checkLogTimeVaild() -> Bool {
        let currentTime = Date()
        if let lastLogTime = self.lastLogTime, currentTime.timeIntervalSince(lastLogTime) < 5 {
            return false
        }
        
        self.lastLogTime = currentTime
        return true
    }
}
