/**
* Function name: BytePlusRTC music mix
* Function brief description: If you need to play sound effects or music files during a call,
* And to make the sound heard by other members of the room, you need to use the mixing function.
* The mixing function can combine the audio data collected by the microphone with audio files, PCM audio data, etc. into one audio stream and publish it to the room.
* Reminder:
* 1. To demonstrate, all functional tokens are generated by the client side TokenGenerator class, please depend on the specific situation when actually accessing
* Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-70141
*/


import UIKit
import SnapKit
import BytePlusRTC

class AudioMediaMixingViewController: BaseViewController, ByteRTCVideoDelegate, ByteRTCRoomDelegate, ByteRTCMediaPlayerEventHandler {
    
    var rtcVideo: ByteRTCVideo?
    var rtcRoom1: ByteRTCRoom?
    var mediaPlayerAudio: ByteRTCMediaPlayer?
    var mediaPlayerPCM: ByteRTCMediaPlayer?
    var audioPlayerId: Int32! = 0
    var pcmPlalerId: Int32! = 1
    var firstPush:Bool = true
    var timer: GCDTimer?
    var startOffset = 0
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        self.mediaPlayerAudio?.setEventHandler(nil)
        self.mediaPlayerPCM?.setEventHandler(nil)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.createUI()
        self.buildRTCEngine()
        self.buildMediaPlayer()
        self.buildActions()
    }
    
    deinit {
        self.timer?.cancel()
        self.timer = nil
        
        self.rtcRoom1?.leaveRoom()
        self.rtcRoom1?.destroy()
        self.rtcRoom1 = nil
        
        ByteRTCVideo.destroyRTCVideo()
        self.rtcVideo = nil
    }
    
    // MARK: Private method
    
    @objc func joinRoom()  {
        let roomId = self.roomTextField.text ?? ""
        let userId = self.userTextField.text ?? ""
        
        var vaild = checkValid(roomId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        vaild = checkValid(userId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        joinButton.isSelected = !joinButton.isSelected
        
        if joinButton.isSelected {
            generatorToken(roomId: roomId, userId: userId) { [weak self] token in
                self?.joinButton.setTitle(LocalizedString("button_leave_room"), for: .normal)
                
                // Join room
                self?.rtcRoom1 = self?.rtcVideo?.createRTCRoom(roomId)
                self?.rtcRoom1?.delegate = self
                
                let userInfo = ByteRTCUserInfo.init()
                userInfo.userId = userId
                
                let roomCfg = ByteRTCRoomConfig.init()
                roomCfg.isAutoPublish = true
                roomCfg.isAutoSubscribeAudio = true
                roomCfg.isAutoSubscribeVideo = true
                
                self?.rtcRoom1?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
            }
        }
        else {
            self.joinButton.setTitle(LocalizedString("button_join_room"), for: .normal)
            self.rtcRoom1?.leaveRoom()
        }
        
    }
    
    func buildRTCEngine() {
        // Create engine
        self.rtcVideo = ByteRTCVideo.createRTCVideo(kAppID, delegate: self, parameters: [:])
        
        // Enable local audio and video collection
        self.rtcVideo?.startVideoCapture()
        self.rtcVideo?.startAudioCapture()
        
        self.bindLocalRenderView()
    }
    
    // Create a music remix player
    func buildMediaPlayer() {
        self.mediaPlayerAudio = self.rtcVideo?.getMediaPlayer(audioPlayerId)
        self.mediaPlayerPCM = self.rtcVideo?.getMediaPlayer(pcmPlalerId)
        
        weak var weakSelf = self
        self.mediaPlayerAudio?.setEventHandler(weakSelf)
        self.mediaPlayerPCM?.setEventHandler(weakSelf)
    }
    
    func buildActions() {
        self.audioVolumeSetting.onValueChanged = { [weak self] (value) in
            self?.mediaPlayerAudio?.setVolume(Int32(value), type:.playoutAndPublish)
        }
        
        self.audioPitchSetting.onValueChanged = { [weak self] (value) in
            if let intValue = Int32(value) {
                self?.mediaPlayerAudio?.setAudioPitch(intValue)
            } else {
                print("Invalid value: \(value)")
            }
        }
        
        self.audioPositionSetting.onValueChanged = { [weak self] (value) in
            if let intValue = Int32(value) {
                self?.mediaPlayerAudio?.setPosition(intValue)
            } else {
                print("Invalid value: \(value)")
            }
        }
        
        self.audioTrackSetting.onValueChanged = { [weak self] (value) in
            if let intValue = Int32(value) {
                self?.mediaPlayerAudio?.selectAudioTrack(intValue)
            } else {
                print("Invalid value: \(value)")
            }
        }
        
        self.audioSpeedSetting.onValueChanged = { [weak self] (value) in
            if let intValue = Int32(value) {
                self?.mediaPlayerAudio?.setPlaybackSpeed(intValue)
            } else {
                print("Invalid value: \(value)")
            }
        }
        
        self.channelModeSheetView.didSelectOption = { [weak self] (value) in
            self?.mediaPlayerAudio?.setAudioDualMonoMode(ByteRTCAudioMixingDualMonoMode(rawValue: value)!)
        }
        
        self.pcmVolumeSetting.onValueChanged = { [weak self] (value) in
            self?.mediaPlayerPCM?.setVolume(Int32(value), type: .playoutAndPublish)
        }
    }
    
    // Start music mixing
    @objc func startAudioMix() {
        var filePath = ""
        // 0 The left and right channels of the audio track, the right channel is the accompaniment, and the left channel is the original vocal.
        // 1 The left and right channels of the audio track are both accompaniment
        if "rtc_audio.m4a" == self.audioTextField1.text {
            filePath = Bundle.main.path(forResource: "rtc_audio.m4a", ofType: "")!
            
        } else if ((self.audioTextField1.text?.hasPrefix("https:")) ?? false) {
            filePath = self.audioTextField1.text!
        } else {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_file_wrong_format"))
        }
        
        let config = ByteRTCMediaPlayerConfig.init()
        config.type = .playoutAndPublish
        config.playCount = 1
        
        // When auto_play=true, it will play automatically and there is no need to call the start interface.
        // When auto_play=false, it will not play automatically and you need to call the start interface.
        config.autoPlay = false
        
        self.mediaPlayerAudio?.open(filePath, config: config)
        self.mediaPlayerAudio?.start()
        // Call back the progress every 1s
        self.mediaPlayerAudio?.setProgressInterval(1000)
    }
    
    @objc func pauseAudioMix() {
        self.mediaPlayerAudio?.pause()
    }
    
    @objc func resumeAudioMix() {
        self.mediaPlayerAudio?.resume()
    }
    
    @objc func stopAudioMix()  {
        self.mediaPlayerAudio?.stop()
    }
    
    // Start pcm mixing
    @objc func startPcmMix() {
        
        let source = ByteRTCMediaPlayerCustomSource.init()
        source.mode = .push
        source.type = .raw
        
        let config  = ByteRTCMediaPlayerConfig.init()
        config.type = .playoutAndPublish
        config.playCount = 1
        config.autoPlay = true
        
        self.mediaPlayerPCM?.open(with: source, config: config)
        
        self.startOffset = 0
        
        if (self.timer != nil) {
            self.timer?.cancel()
            self.timer = nil
        }
        
        weak var weakSelf = self
        
        // Turn on the timer to push data, 10ms interval
        self.timer = GCDTimer(interval: .milliseconds(10)) {
            weakSelf!.pushPCMData()
        }
        
        self.timer!.start()
    }
    
    @objc func getAudioPosition() {
        let currentPosion = self.mediaPlayerAudio?.getPosition()
        self.currentProgressLabel.text = "\(currentPosion ?? 0)"
    }
    
    @objc func scrollViewAction()  {
        self.view.endEditing(true)
    }
    
    func pushPCMData() {
        if let mediaPlayerPCM = self.mediaPlayerPCM {
            // Data per 10ms = number of samples * number of channels * number of bytes occupied by samples. The pcm file has a sampling rate of 16000, mono channel, and each sample occupies 2 bytes.
            var size = 160 * 1 * 2
            
            if self.firstPush {
                // It is recommended to push 200ms data for the first time to avoid noise
                size = size * 20
                self.firstPush = false
            }
            
            let filePath = Bundle.main.path(forResource: "rtc_audio_16k_mono", ofType: "pcm")!
            let url = URL(fileURLWithPath: filePath)
            
            guard let fileData = try? Data(contentsOf: url) else {
                print("Failed to read PCM file data.")
                return
            }
            
            let endOffset = self.startOffset + size
            
            if endOffset >= fileData.count {
                // If it is played only once, it will stop if the file length is exceeded.
                self.stopPcmMix()
                return
                
                // If you need to repeat playback, read it from the beginning
                // self.startOffset = 0
                // endOffset = self.startOffset + size
            }
            
            let audioData: Data = fileData.subdata(in: startOffset..<endOffset)
            self.startOffset = endOffset
            
            let audioFrame = ByteRTCAudioFrame()
            audioFrame.channel = .mono
            audioFrame.sampleRate = .rate16000
            // Each sample occupies 2 bytes
            audioFrame.samples = Int32(size) / 2
            audioFrame.buffer = audioData
            
            mediaPlayerPCM.pushExternalAudioFrame(audioFrame)
        }
    }
    
    @objc func stopPcmMix()  {
        self.mediaPlayerPCM?.stop()
        self.timer?.cancel()
    }
    
    func bindLocalRenderView() {
        // Set the local rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = self.localView.videoView
        canvas.renderMode = .hidden
        self.localView.userId = userTextField.text ?? ""
        
        self.rtcVideo?.setLocalVideoCanvas(.main, withCanvas: canvas);
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.view.endEditing(true)
    }
    
    func createUI() -> Void {
        
        // ScrollView
        self.view.addSubview(scrollView)
        scrollView.snp.makeConstraints { make in
            make.top.equalTo(topView.snp.bottom)
            make.left.right.bottom.equalToSuperview()
        }
        
        let view = UIView()
        scrollView.addSubview(view)
        
        view.snp.makeConstraints { make in
            make.edges.equalToSuperview()
            make.width.equalToSuperview()
        }

        // Add UI
        view.addSubview(containerView)
        containerView.snp.makeConstraints { make in
            make.top.left.right.equalToSuperview()
            make.height.equalTo(scrollView).multipliedBy(0.4)
        }
        
        containerView.addSubview(localView)
        localView.snp.makeConstraints { make in
            make.left.top.equalTo(self.containerView)
            make.width.height.equalTo(self.containerView)
        }
        
        view.addSubview(roomLabel)
        view.addSubview(roomTextField)
        view.addSubview(userLabel)
        view.addSubview(userTextField)
        view.addSubview(joinButton)
        
        roomLabel.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
        }
        
        roomTextField.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel)
            make.left.equalTo(roomLabel.snp.right).offset(10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        userLabel.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel)
        }
        
        userTextField.snp.makeConstraints { make in
            make.centerY.equalTo(roomLabel)
            make.left.equalTo(userLabel.snp.right).offset(10)
            make.right.equalTo(self.view).offset(-10)
            make.width.equalTo(100)
            make.height.equalTo(30)
        }
        
        joinButton.snp.makeConstraints { make in
            make.top.equalTo(roomLabel.snp.bottom).offset(20)
            make.left.equalTo(roomLabel)
            make.right.equalTo(userTextField)
            make.height.equalTo(36)
        }
                
        view.addSubview(fileBackgroundView)
        fileBackgroundView.snp.makeConstraints { make in
            make.top.equalTo(joinButton.snp.bottom).offset(20)
            make.left.right.equalTo(joinButton)
            make.height.equalTo(486)
        }
        
        fileBackgroundView.addSubview(audioMixLabel)
        fileBackgroundView.addSubview(audioTextField1)
        fileBackgroundView.addSubview(startButton1)
        fileBackgroundView.addSubview(pauseButton1)
        fileBackgroundView.addSubview(resumeButton1)
        fileBackgroundView.addSubview(stopButton1)
        
        audioMixLabel.snp.makeConstraints { make in
            make.left.top.equalToSuperview().offset(10)
        }
        
        audioTextField1.snp.makeConstraints { make in
            make.top.equalTo(audioMixLabel.snp.bottom).offset(10)
            make.left.equalTo(audioMixLabel)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(30)
        }
        
        startButton1.snp.makeConstraints { make in
            make.top.equalTo(audioTextField1.snp.bottom).offset(10)
            make.left.equalTo(audioTextField1)
            make.height.equalTo(36)
        }
        
        pauseButton1.snp.makeConstraints { make in
            make.centerY.equalTo(startButton1)
            make.left.equalTo(startButton1.snp.right).offset(10)
            make.width.height.equalTo(startButton1)
        }

        resumeButton1.snp.makeConstraints { make in
            make.centerY.equalTo(startButton1)
            make.left.equalTo(pauseButton1.snp.right).offset(10)
            make.width.height.equalTo(startButton1)
        }

        stopButton1.snp.makeConstraints { make in
            make.centerY.equalTo(startButton1)
            make.left.equalTo(resumeButton1.snp.right).offset(10)
            make.width.height.equalTo(startButton1)
            make.right.equalTo(audioTextField1)
        }
        
        fileBackgroundView.addSubview(audioVolumeSetting)
        audioVolumeSetting.snp.makeConstraints { make in
            make.top.equalTo(startButton1.snp.bottom).offset(10)
            make.left.equalTo(startButton1)
            make.right.equalTo(stopButton1)
        }
        
        fileBackgroundView.addSubview(totalTimeLabel1)
        totalTimeLabel1.snp.makeConstraints { make in
            make.top.equalTo(audioVolumeSetting.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        fileBackgroundView.addSubview(audioPositionSetting)
        audioPositionSetting.snp.makeConstraints { make in
            make.top.equalTo(totalTimeLabel1.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        fileBackgroundView.addSubview(totalChannelLabel1)
        
        totalChannelLabel1.snp.makeConstraints { make in
            make.top.equalTo(audioPositionSetting.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        fileBackgroundView.addSubview(audioTrackSetting)
        audioTrackSetting.snp.makeConstraints { make in
            make.top.equalTo(totalChannelLabel1.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        fileBackgroundView.addSubview(audioPitchSetting)
        audioPitchSetting.snp.makeConstraints { make in
            make.top.equalTo(audioTrackSetting.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        fileBackgroundView.addSubview(audioSpeedSetting)
        audioSpeedSetting.snp.makeConstraints { make in
            make.top.equalTo(audioPitchSetting.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        fileBackgroundView.addSubview(currentPostionLabel)
        fileBackgroundView.addSubview(currentProgressLabel)
        
        currentPostionLabel.snp.makeConstraints { make in
            make.top.equalTo(audioSpeedSetting.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
        }
        
        currentProgressLabel.snp.makeConstraints { make in
            make.centerY.equalTo(currentPostionLabel)
            make.left.equalTo(currentPostionLabel.snp.right).offset(10)
        }
        
        fileBackgroundView.addSubview(channelModeSheetView)
        channelModeSheetView.snp.makeConstraints { make in
            make.top.equalTo(currentPostionLabel.snp.bottom).offset(11)
            make.left.equalToSuperview().offset(10)
        }
        
        view.addSubview(pcmBackgroundView)
        
        pcmBackgroundView.snp.makeConstraints { make in
            make.top.equalTo(fileBackgroundView.snp.bottom).offset(20)
            make.left.right.equalTo(joinButton)
            make.height.equalTo(180)
            make.bottom.equalToSuperview().offset(-10)
        }
        
        pcmBackgroundView.addSubview(pcmMixLabel)
        pcmBackgroundView.addSubview(pcmField)

        pcmBackgroundView.addSubview(pcmStartButton)
        pcmBackgroundView.addSubview(pcmStopButton)
        
        pcmBackgroundView.addSubview(pcmVolumeSetting)
        
        pcmMixLabel.snp.makeConstraints { make in
            make.left.top.equalToSuperview().offset(10)
        }
        
        pcmField.snp.makeConstraints { make in
            make.top.equalTo(pcmMixLabel.snp.bottom).offset(10)
            make.left.equalTo(pcmMixLabel)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(30)
        }
        
        pcmStartButton.snp.makeConstraints { make in
            make.top.equalTo(pcmField.snp.bottom).offset(20)
            make.left.equalTo(pcmField)
            make.height.equalTo(36)
        }
        
        pcmStopButton.snp.makeConstraints { make in
            make.centerY.equalTo(pcmStartButton)
            make.left.equalTo(pcmStartButton.snp.right).offset(10)
            make.width.height.equalTo(pcmStartButton)
            make.right.equalToSuperview().offset(-10)
        }
        
        pcmVolumeSetting.snp.makeConstraints { make in
            make.top.equalTo(pcmStartButton.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.bottom.equalToSuperview().offset(-10)
        }
    }
    
    // MARK: Lazy laod
    lazy var scrollView: UIScrollView = {
        let scrollView = UIScrollView()
        scrollView.showsVerticalScrollIndicator = false
        scrollView.isUserInteractionEnabled = true
        let tap = UITapGestureRecognizer(target: self, action: #selector(scrollViewAction))
        scrollView.addGestureRecognizer(tap)
        return scrollView
    }()
    
    lazy var roomLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("hint_room_id")
        return label
    }()
    
    lazy var roomTextField: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var userLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("hint_user_id")
        return label
    }()
    
    lazy var userTextField: UITextField = {
        let textField = UITextField()
        textField.borderStyle = .roundedRect
        return textField
    }()
    
    lazy var joinButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_join_room"), for: .normal)
        button.addTarget(self, action: #selector(joinRoom), for: .touchUpInside)
        return button
    }()
    
    lazy var fileBackgroundView: UIView = {
        let view = UIView()
        view.backgroundColor = UIColor(red: 252/255.0, green: 253/255.0, blue: 254/255.0, alpha: 1.0)
        view.layer.borderWidth = 1
        view.layer.borderColor = UIColor(red: 234/255.0, green: 237/255.0, blue: 241/255.0, alpha: 1.0).cgColor
        view.layer.cornerRadius = 4
        view.layer.masksToBounds = true
        return view
    }()
    
    lazy var audioMixLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_mixing_music_title")
        return label
    }()
    
    lazy var audioTextField1: TextFieldView = {
        let textField = TextFieldView()
        textField.title = LocalizedString("label_mixing_file_label")
        textField.text = "rtc_audio.m4a"
        return textField
    }()
    
    lazy var startButton1: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_start"), for: .normal)
        button.addTarget(self, action: #selector(startAudioMix), for: .touchUpInside)
        return button
    }()
    
    lazy var pauseButton1: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_pause"), for: .normal)
        button.addTarget(self, action: #selector(pauseAudioMix), for: .touchUpInside)
        return button
    }()
    
    lazy var resumeButton1: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_resume"), for: .normal)
        button.addTarget(self, action: #selector(resumeAudioMix), for: .touchUpInside)
        return button
    }()
    
    lazy var stopButton1: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_stop"), for: .normal)
        button.addTarget(self, action: #selector(stopAudioMix), for: .touchUpInside)
        return button
    }()
    
    lazy var audioVolumeSetting: SliderView = {
        let settingView = SliderView(minValue: 0, maxValue: 400, defaultValue: 100)
        settingView.title = LocalizedString("label_volume")
        return settingView
    }()
    
    lazy var audioPitchSetting: SettingItemView = {
        let settingView = SettingItemView()
        settingView.title = LocalizedString("label_voice_pitch")
        settingView.inputTextField.keyboardType = .default
        return settingView
    }()
    
    lazy var totalTimeLabel1: UILabel = {
        let label = UILabel()
        label.text = "\(LocalizedString("label_total_time_length")) : --ms"
        return label
    }()
    
    lazy var audioPositionSetting: SettingItemView = {
        let settingView = SettingItemView()
        settingView.title = LocalizedString("label_set_progress")
        return settingView
    }()
    
    lazy var totalChannelLabel1: UILabel = {
        let label = UILabel()
        label.text = "\(LocalizedString("label_hint_track")) --"
        return label
    }()
    
    lazy var audioTrackSetting: SettingItemView = {
        let settingView = SettingItemView()
        settingView.title = LocalizedString("label_set_audio_track")
        return settingView
    }()
    
    lazy var audioSpeedSetting: SettingItemView = {
        let settingView = SettingItemView()
        settingView.title = LocalizedString("label_hint_speed")
        return settingView
    }()
    
    lazy var channelModeSheetView: ActionSheetView = {
        let actionSheetView = ActionSheetView.init(title: LocalizedString("label_hint_channel_mode"), optionArray: ["Auto","ModeL","ModeR","ModeMix"], defaultIndex: 0)
        actionSheetView.presentingViewController = self
        
        return actionSheetView
    }()
    
    lazy var currentPostionLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_play_progress")
        return label
    }()
    
    lazy var currentProgressLabel: UILabel = {
        let label = UILabel()
        label.text = "-"
        return label
    }()
    
    lazy var pcmBackgroundView: UIView = {
        let view = UIView()
        view.backgroundColor = UIColor(red: 252/255.0, green: 253/255.0, blue: 254/255.0, alpha: 1.0)
        view.layer.borderWidth = 1
        view.layer.borderColor = UIColor(red: 234/255.0, green: 237/255.0, blue: 241/255.0, alpha: 1.0).cgColor
        view.layer.cornerRadius = 4
        view.layer.masksToBounds = true
        return view
    }()
    
    lazy var pcmMixLabel: UILabel = {
        let label = UILabel()
        label.text = LocalizedString("label_pcm_mixing")
        return label
    }()
    
    lazy var pcmField: TextFieldView = {
        let field = TextFieldView()
        field.title = LocalizedString("label_pcm_mixing_file")
        field.text = "rtc_audio_16k_mono.pcm"
        return field
    }()
    
    lazy var pcmStartButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_start"), for: .normal)
        button.addTarget(self, action: #selector(startPcmMix), for: .touchUpInside)
        return button
    }()
    
    lazy var pcmStopButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_stop"), for: .normal)
        button.addTarget(self, action: #selector(stopPcmMix), for: .touchUpInside)
        return button
    }()
    
    lazy var pcmVolumeSetting: SliderView = {
        let settingView = SliderView(minValue: 0, maxValue: 400, defaultValue: 100)
        settingView.title = LocalizedString("label_volume")
        return settingView
    }()
    
    lazy var containerView: UIView = {
        let view = UIView.init()
        view.backgroundColor = .groupTableViewBackground
        return view
    }()
    
    lazy var localView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    // MARK: ByteRTCVideoDelegate & ByteRTCRoomDelegate
    // Room entry status
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onRoomStateChanged roomId: String, withUid uid: String, state: Int, extraInfo: String) {
        ToastComponents.shared.show(withMessage: "onRoomStateChanged uid: \(uid) state:\(state)")
        
    }
    
    // MARK: ByteRTCMediaPlayerEventHandler
    // Mix status
    func onMediaPlayerStateChanged(_ playerId: Int32, state: ByteRTCPlayerState, error: ByteRTCPlayerError) {
        ToastComponents.shared.show(withMessage: "onMediaPlayerStateChanged playerId: \(playerId) state:\(state.rawValue) error:\(error.rawValue)")
        
        if playerId == self.audioPlayerId && state == .playing {
            let totalTime = self.mediaPlayerAudio?.getTotalDuration()
            let tracks = self.mediaPlayerAudio?.getAudioTrackCount()
            
            DispatchQueue.main.async {
                self.totalTimeLabel1.text = "\(LocalizedString("label_total_time_length")) : \(totalTime ?? 0)"
                self.totalChannelLabel1.text = "\(LocalizedString("label_hint_track")) : \(tracks ?? 0)"
            }
            
        }
    }
    
    // Playback progress
    func onMediaPlayerPlayingProgress(_ playerId: Int32, progress: Int64) {
        if playerId == self.audioPlayerId {
            DispatchQueue.main.async {
                self.currentProgressLabel.text = "\(progress)"
            }
        }
    }
    
}
