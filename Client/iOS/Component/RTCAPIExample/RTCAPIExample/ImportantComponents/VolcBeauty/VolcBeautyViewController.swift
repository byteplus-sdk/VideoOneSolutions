/*
* Function name: BytePlusRTC beauty function
* Function brief description: Shows the use of beauty, filters, stickers, and background segmentation
* Reminder:
* 1. To demonstrate, all functional tokens are generated by the client side TokenGenerator class, please depend on the specific situation when actually accessing
* 2. This function requires payment, please contact the beauty technical support team to obtain the Standard/Lite version of v4.4.2 +
* Effects SDK and License and effects packages that meet business functional requirements.
* 2.2 After applying for paid use:
* 2.3 Modify the CVLicenseName in Demo Config.h to the filename of the license
* 2.3 Put the model and other resources in the ApiExample/ApiExample/ImportantComponents/Beauty/VolcBeauty/resource directory
*
* Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-114717
*/


import UIKit
import SnapKit
import BytePlusRTC

@objc(VolcBeautyViewController)
class VolcBeautyViewController: BaseViewController, ByteRTCVideoDelegate, ByteRTCRoomDelegate,BeautyBarViewDelegate {
    
    var rtcVideo: ByteRTCVideo?
    var rtcRoom: ByteRTCRoom?
    let roomId = "202311"
    let userId = "888888"
    
    private var makeupNodes: [String] = []
    private var rtcVideoEffect: ByteRTCVideoEffect?
    
    deinit {
        self.rtcRoom?.leaveRoom()
        self.rtcRoom?.destroy()
        self.rtcRoom = nil
        
        ByteRTCVideo.destroyRTCVideo()
        self.rtcVideo = nil
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.createUI()
        self.buildRTCEngine()
        self.buildVideoEffect()
        self.bindLocalRenderView()
        self.joinRoom()
    }
    
    // MARK: Private method
    func createUI() -> Void {
        view.addSubview(containerView)
        self.containerView.addSubview(localView)
        
        containerView.snp.makeConstraints { make in
            make.top.equalTo(topView.snp.bottom)
            make.height.equalTo(self.view).multipliedBy(0.6)
            make.left.right.equalTo(self.view)
        }
        
        self.localView.snp.makeConstraints { make in
            make.left.top.equalTo(self.containerView)
            make.height.equalTo(self.containerView)
            make.width.equalTo(self.containerView)
        }
        
        // Beauty operation bar
        view.addSubview(beautyView)
        beautyView.snp.makeConstraints { make in
            make.bottom.equalTo(self.view)
            make.left.right.equalToSuperview()
            make.height.equalTo(240)
        }
    }
    
    func buildRTCEngine() {
        // Create engine
        self.rtcVideo = ByteRTCVideo.createRTCVideo(kAppID, delegate: self, parameters: [:])
        
        // Enable local audio and video collection
        self.rtcVideo?.startVideoCapture()
        self.rtcVideo?.startAudioCapture()
        
        // Set video orientation
        self.rtcVideo?.setVideoOrientation(.portrait)
    }
    
    func buildVideoEffect() {
        // Initialization
        self.rtcVideoEffect = self.rtcVideo?.getVideoEffectInterface()
        
        // License verification
        let licensePath = EffectResource.licensePath()
        let modelPath = EffectResource.modelPath()
        let errorCode = self.rtcVideoEffect?.initCVResource(licensePath, withAlgoModelDir: modelPath)
        
        if errorCode == 0 {
            print("VolcBeauty initCVResource success")
        } else {
            print("VolcBeauty initCVResource failed \(errorCode ?? -1)")
        }
        
        // Create video effects engine
        let isEnable = self.rtcVideoEffect?.enable()
        if isEnable == 0 {
            print("VolcBeauty enable video effect success")
        } else {
            print("VolcBeauty enable video effect failed \(isEnable ?? -1)")
        }
        
        // Set up video special effects material package
        let beautyPath = EffectResource.beautyCameraPath()
        let reshapePath = EffectResource.reshapeCameraPath()
        self.makeupNodes = [beautyPath, reshapePath]
        let isEffectNodes = self.rtcVideoEffect?.setEffectNodes(self.makeupNodes) ?? -1
        if isEffectNodes == 0 {
            print("VolcBeauty enable effect nodes success")
        } else {
            print("VolcBeauty enable effect nodes failed \(isEnable ?? -1)")
        }
        
        // Default filter
        self.rtcVideoEffect?.setColorFilter(EffectResource.filterPath(withName: "Filter_06_03"))
        self.rtcVideoEffect?.setColorFilterIntensity(0.0)
    }
    
    func bindLocalRenderView() {
        // Set local rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = self.localView.videoView
        canvas.renderMode = .fit
        self.localView.userId = userId
        
        self.rtcVideo?.setLocalVideoCanvas(.main, withCanvas: canvas);
    }
    
    @objc func joinRoom()  {
        generatorToken(roomId: roomId, userId: userId) { [weak self] token in
            // Join room
            self?.rtcRoom = self?.rtcVideo?.createRTCRoom(self?.roomId ?? "")
            self?.rtcRoom?.delegate = self
            
            let userInfo = ByteRTCUserInfo.init()
            userInfo.userId = self?.userId ?? ""
            
            let roomCfg = ByteRTCRoomConfig.init()
            roomCfg.isAutoPublish = true
            roomCfg.isAutoSubscribeAudio = true
            roomCfg.isAutoSubscribeVideo = true
            
            self?.rtcRoom?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
        }
    }
    
    //MARK: Beauty click events
    func beautyBarView(barView: BeautyBarView, didClickedEffect model: EffectModel) {
        switch model.type {
        case .sticker:
            let stickerPath = EffectResource.stickerPath(withName: model.key!)
            
            if model.selected {
                let allNodes = self.makeupNodes + [stickerPath]
                self.rtcVideoEffect?.setEffectNodes(allNodes)
            } else {
                self.rtcVideoEffect?.setEffectNodes(self.makeupNodes)
            }
            break
        case .filter:
            let filterPath = EffectResource.filterPath(withName: model.key!)
            self.rtcVideoEffect?.setColorFilter(filterPath)
            self.rtcVideoEffect?.setColorFilterIntensity(model.value)
            break
        case .virtual:
            let source = ByteRTCVirtualBackgroundSource()
            
            if model.selected {
                if model.subType == .image {
                    let path = Bundle.main.path(forResource: "background", ofType: "jpg") ?? ""
                    source.sourceType = .image
                    source.sourcePath = path
                } else {
                    source.sourceType = .color
                    source.sourceColor = Int32(bitPattern: UInt32(0xff1678ff))
                }
                
                let portraitPath = EffectResource.getByteEffectPortraitPath()
                let result = self.rtcVideoEffect?.enableVirtualBackground(portraitPath, with: source) ?? -1
                if result != 0 {
                    ToastComponents.shared.show(withMessage: LocalizedString("开启背景分割失败"))
                }
            } else {
                self.rtcVideoEffect?.disableVirtualBackground()
            }
            break
        default:
            break
        }
    }
    
    // Modify effect strength value
    func beautyBarView(barView: BeautyBarView, didChangeEffectValue model: EffectModel) {
        switch model.type {
        case .beauty:
            if model.subType == .reshape {
                let path = EffectResource.reshapeCameraPath()
                self.rtcVideoEffect?.updateNode(path, key: model.key!, value: model.value)
            } else {
                let path = EffectResource.beautyCameraPath()
                self.rtcVideoEffect?.updateNode(path, key: model.key!, value: model.value)            }
            
        case .filter:
            self.rtcVideoEffect?.setColorFilterIntensity(model.value)
            
        default:
            
            break
        }
    }
    
    // MARK: ByteRTCVideoDelegate & ByteRTCRoomDelegate
    // Room entry status
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onRoomStateChanged roomId: String, withUid uid: String, state: Int, extraInfo: String) {
        ToastComponents.shared.show(withMessage: "onRoomStateChanged uid: \(uid) state:\(state)")
        
    }
    
    // MARK: Lazy laod
    lazy var beautyView: BeautyBarView = {
        let view = BeautyBarView.init(frame: CGRectZero)
        view.delegate = self
        return view
    }()
    
    lazy var containerView: UIView = {
        let view = UIView.init()
        view.backgroundColor = .groupTableViewBackground
        return view
    }()
    
    lazy var localView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
}
