/**
* Function name: SEI message
* Function brief description: Send a SEI message, and the SEI data will be added to consecutive "repeatCount + 1" video frames starting from the current frame.
* Reminder:
* 1. To demonstrate, all functional tokens are generated by the client side TokenGenerator class, please depend on the specific situation when actually accessing
* 2. In the video call scenario, the SEI is sent with the video frame, while in the voice call scenario,
The SDK automatically publishes black frames with a resolution of 16 x 16 pixels to carry SEI data.
* 3. When making a voice call, this parameter should be set to "ByteRTCStreamIndexMain", otherwise the SEI data will be discarded and cannot be sent to the remote user.
*/




import UIKit
import SnapKit
import BytePlusRTC

class SEIViewController: BaseViewController, ByteRTCVideoDelegate, ByteRTCRoomDelegate, ByteRTCMixedStreamObserver {
    
    var rtcVideo: ByteRTCVideo?
    var rtcRoom: ByteRTCRoom?
    var users : Array = Array<ByteRTCRemoteStreamKey>()
    var mixConfig: ByteRTCMixedStreamConfig?
    let taskId = "1999"
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.createUI()
        self.buildRTCEngine()
    }
    
    deinit {
        
        self.rtcRoom?.leaveRoom()
        self.rtcRoom?.destroy()
        self.rtcRoom = nil
        
        ByteRTCVideo.destroyRTCVideo()
        self.rtcVideo = nil
    }
    
    // MARK: Private method
    
    @objc func joinRoom()  {
        let roomId = self.roomSettingItem.text ?? ""
        let userId = self.userSettingItem.text ?? ""
        
        var vaild = checkValid(roomId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        vaild = checkValid(userId)
        if vaild == false {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_check_valid_false"))
            return
        }
        
        joinButton.isSelected = !joinButton.isSelected
        
        if joinButton.isSelected {
            generatorToken(roomId: roomId, userId: userId) { [weak self] token in
                self?.joinButton.setTitle(LocalizedString("button_leave_room"), for: .normal)
                
                // Join room
                self?.rtcRoom = self?.rtcVideo?.createRTCRoom(roomId)
                self?.rtcRoom?.delegate = self
                
                let userInfo = ByteRTCUserInfo.init()
                userInfo.userId = userId
                
                let roomCfg = ByteRTCRoomConfig.init()
                roomCfg.isAutoPublish = true
                roomCfg.isAutoSubscribeAudio = true
                roomCfg.isAutoSubscribeVideo = true
                
                self?.rtcRoom?.joinRoom(token, userInfo: userInfo, roomConfig: roomCfg)
            }
        } else {
            self.joinButton.setTitle(LocalizedString("button_join_room"), for: .normal)
            self.rtcRoom?.leaveRoom()
        }
    }
    
    func buildRTCEngine() {
        // Create engine
        self.rtcVideo = ByteRTCVideo.createRTCVideo(kAppID, delegate: self, parameters: [:])
        
        // Enable local audio and video collection
        self.rtcVideo?.startVideoCapture()
        self.rtcVideo?.startAudioCapture()
        
        self.bindLocalRenderView()
        
        // Set default merge parameters
        self.mixConfig = ByteRTCMixedStreamConfig.default()
    }
    
    func bindLocalRenderView() {
        // Set local rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = self.localView.videoView
        canvas.renderMode = .hidden
        self.localView.userId = userSettingItem.text ?? ""
        
        self.rtcVideo?.setLocalVideoCanvas(.main, withCanvas: canvas);
    }
    
    func updateRenderView() {
        // Get the first user of the room
        var remoteUser:ByteRTCRemoteStreamKey?
        
        for streamKey in self.users {
            if remoteUser == nil && streamKey.roomId ==  self.roomSettingItem.text {
                remoteUser = streamKey
            }
        }
        
        if (remoteUser != nil) {
            self.bindRemoteRenderView(view: self.firstRemoteView,roomId: (remoteUser?.roomId)!,userId: (remoteUser?.userId)!)
        }
    }
    
    @objc func startPushCDN() {
        if let text = self.urlTextFieldView.text, !text.isEmpty {
            self.mixConfig?.pushURL = text
            
            let roomId = roomSettingItem.text
            let userId = userSettingItem.text
            
            self.mixConfig?.layoutConfig.regions = self.getMixRegions()
            self.mixConfig?.layoutConfig.backgroundColor = "#FFFFFF"
            
            // Additional data transparently transmitted by the confluent user is received through the SEI of the puller.
            self.mixConfig?.layoutConfig.userConfigExtraInfo = self.layoutTextFieldView.text ?? ""
            
            self.mixConfig?.roomID = roomId!
            self.mixConfig?.userID = userId!
            
            self.rtcVideo?.startPushMixedStream(toCDN: taskId, mixedConfig: self.mixConfig, observer: self)
        } else {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_mix_url_false"))
        }
    }
    
    @objc func updatePushCDN()  {
        // Additional data transparently transmitted by the confluent user is received through the SEI of the puller.
        self.mixConfig?.layoutConfig.userConfigExtraInfo = self.layoutTextFieldView.text ?? ""
        
        self.rtcVideo?.updatePushMixedStream(toCDN: taskId, mixedConfig: self.mixConfig!)
    }
    
    
    @objc func stopPushCDN()  {
        self.rtcVideo?.stopPushStreamToCDN(taskId)
    }
    
    func getMixRegions() -> [ByteRTCMixedStreamLayoutRegionConfig] {
        let roomId = roomSettingItem.text
        let userId = userSettingItem.text
        
        var regions = [ByteRTCMixedStreamLayoutRegionConfig]()
        
        let width = 1.0
        let height = 1.0
        
        // Local user
        let regionConfig = ByteRTCMixedStreamLayoutRegionConfig.init()
        regionConfig.userID = userId!
        regionConfig.roomID = roomId!
        regionConfig.locationX = 0
        regionConfig.locationY = 0
        regionConfig.widthProportion = width
        regionConfig.heightProportion = height
        regionConfig.zOrder = 0
        regionConfig.isLocalUser = true
        regionConfig.mediaType = .audioAndVideo
        
        regions.append(regionConfig)
        
        return regions
    }
    
    // Send SEI information
    @objc func sendSEIMessage()  {
        let message = self.seiTextFieldView.text;
        
        if !message!.isEmpty, let data = message?.data(using: .utf8) {
            self.rtcVideo?.sendSEIMessage(.main, andMessage: data, andRepeatCount: 3, andCountPerFrame: .single)
        }else {
            ToastComponents.shared.show(withMessage: LocalizedString("toast_send_message_empty_false"))
        }

    }
    
    func bindRemoteRenderView(view: UserVideoView, roomId: String, userId: String) {
        // Set the remote user video rendering view
        let canvas = ByteRTCVideoCanvas.init()
        canvas.view = view.videoView
        canvas.renderMode = .hidden
        view.userId = userId

        let streamKey = ByteRTCRemoteStreamKey.init()
        streamKey.userId = userId
        streamKey.roomId = roomId;
        streamKey.streamIndex = .main
        
        self.rtcVideo?.setRemoteVideoCanvas(streamKey, withCanvas: canvas)
    }
    
    func createUI() -> Void {
        view.addSubview(containerView)
        containerView.snp.makeConstraints { make in
            make.left.right.equalTo(self.view)
            make.top.equalTo(topView.snp.bottom)
        }
        
        self.containerView.addSubview(localView)
        self.containerView.addSubview(firstRemoteView)
        self.localView.snp.makeConstraints { make in
            make.left.top.equalTo(self.containerView)
            make.height.equalTo(self.containerView)
            make.width.equalTo(self.containerView).multipliedBy(0.5)
        }
        
        self.firstRemoteView.snp.makeConstraints { make in
            make.right.bottom.equalTo(self.containerView)
            make.height.equalTo(self.containerView)
            make.width.equalTo(self.containerView).multipliedBy(0.5)
        }

        view.addSubview(roomSettingItem)
        view.addSubview(userSettingItem)
        view.addSubview(joinButton)
        
        roomSettingItem.snp.makeConstraints { make in
            make.top.equalTo(containerView.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.height.equalTo(30)
        }
        
        userSettingItem.snp.makeConstraints { make in
            make.centerY.equalTo(roomSettingItem)
            make.left.equalTo(roomSettingItem.snp.right).offset(20)
            make.right.equalToSuperview().offset(-10)
            make.width.height.equalTo(roomSettingItem)
        }
        
        joinButton.snp.makeConstraints { make in
            make.top.equalTo(roomSettingItem.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(36)
        }
        
        view.addSubview(seiTextFieldView)
        view.addSubview(sendButton)
        
        seiTextFieldView.snp.makeConstraints { make in
            make.top.equalTo(joinButton.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(30)
        }
        
        sendButton.snp.makeConstraints { make in
            make.top.equalTo(seiTextFieldView.snp.bottom).offset(10)
            make.left.right.width.height.equalTo(joinButton)
        }
        
        view.addSubview(urlTextFieldView)
        view.addSubview(layoutTextFieldView)
        view.addSubview(startPushButton)
        view.addSubview(updatePushButton)
        view.addSubview(stopPushButton)

        urlTextFieldView.snp.makeConstraints { make in
            make.top.equalTo(sendButton.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(30)
        }
        
        layoutTextFieldView.snp.makeConstraints { make in
            make.top.equalTo(urlTextFieldView.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(30)
        }
        
        startPushButton.snp.makeConstraints { make in
            make.top.equalTo(layoutTextFieldView.snp.bottom).offset(10)
            make.left.equalToSuperview().offset(10)
            make.height.equalTo(30)
        }
        
        updatePushButton.snp.makeConstraints { make in
            make.centerY.equalTo(startPushButton)
            make.left.equalTo(startPushButton.snp.right).offset(20)
            make.width.height.equalTo(startPushButton)
        }
        
        stopPushButton.snp.makeConstraints { make in
            make.centerY.equalTo(startPushButton)
            make.left.equalTo(updatePushButton.snp.right).offset(20)
            make.right.equalToSuperview().offset(-10)
            make.width.height.equalTo(startPushButton)
        }
        
        view.addSubview(receivedSEIItem)
        receivedSEIItem.snp.makeConstraints { make in
            make.top.equalTo(startPushButton.snp.bottom).offset(20)
            make.left.equalToSuperview().offset(10)
            make.right.equalToSuperview().offset(-10)
            make.height.equalTo(30)
            make.bottom.equalTo(self.view.safeAreaLayoutGuide.snp.bottom).offset(-10)
        }
    }
    
    // MARK: Lazy laod
    
    lazy var roomSettingItem: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("hint_room_id")
        return settingView
    }()
    
    lazy var userSettingItem: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("hint_user_id")
        return settingView
    }()
    
    lazy var joinButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_join_room"), for: .normal)
        button.addTarget(self, action: #selector(joinRoom), for: .touchUpInside)
        return button
    }()
    
    lazy var seiTextFieldView: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("example_sei_messaging")
        settingView.inputTextField.keyboardType = .default
        return settingView
    }()
    
    lazy var sendButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_send"), for: .normal)
        button.addTarget(self, action: #selector(sendSEIMessage), for: .touchUpInside)
        return button
    }()
    
    lazy var urlTextFieldView: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("hint_cdn_url")
        if let cdnUrl = kCDNUrl as String?, !cdnUrl.isEmpty {
            settingView.text = cdnUrl
        } else {
            RTCTokenProtocol().getRTMPAddr(taskId) { [weak settingView] addr in
                settingView?.text = addr
            }
        }
        return settingView
    }()
    
    lazy var layoutTextFieldView: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("label_setting_mix")
        settingView.inputTextField.keyboardType = .default
        return settingView
    }()
    
    lazy var startPushButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_start_transcoding"), for: .normal)
        button.titleLabel?.adjustsFontSizeToFitWidth = true
        button.titleLabel?.textAlignment = .center
        button.addTarget(self, action: #selector(startPushCDN), for: .touchUpInside)
        return button
    }()
    
    lazy var updatePushButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_update_transcoding"), for: .normal)
        button.titleLabel?.adjustsFontSizeToFitWidth = true
        button.titleLabel?.textAlignment = .center
        button.addTarget(self, action: #selector(updatePushCDN), for: .touchUpInside)
        return button
    }()
    
    lazy var stopPushButton: UIButton = {
        let button = BaseButton()
        button.setTitle(LocalizedString("button_stop_transcoding"), for: .normal)
        button.titleLabel?.adjustsFontSizeToFitWidth = true
        button.titleLabel?.textAlignment = .center
        button.addTarget(self, action: #selector(stopPushCDN), for: .touchUpInside)
        return button
    }()
    
    lazy var receivedSEIItem: TextFieldView = {
        let settingView = TextFieldView()
        settingView.title = LocalizedString("hint_sei_message")
        return settingView
    }()
    
    lazy var containerView: UIView = {
        let view = UIView.init()
        view.backgroundColor = .groupTableViewBackground
        return view
    }()
    
    lazy var localView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    lazy var firstRemoteView: UserVideoView = {
        let view = UserVideoView.init()
        return view
    }()
    
    // MARK: ByteRTCVideoDelegate & ByteRTCRoomDelegate
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onRoomStateChanged roomId: String, withUid uid: String, state: Int, extraInfo: String) {
        ToastComponents.shared.show(withMessage: "onRoomStateChanged uid: \(uid) state:\(state)")
        
    }
    
    // Remote user publishing stream
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserPublishStream userId: String, type: ByteRTCMediaStreamType) {
        ToastComponents.shared.show(withMessage: "onUserPublishStream uid: \(userId)")
        
        if type == .video || type == .both {
            
            let streamKey = ByteRTCRemoteStreamKey.init()
            streamKey.userId = userId
            streamKey.roomId = rtcRoom.getId();
            streamKey.streamIndex = .main
            
            self.users.append(streamKey)
            
            DispatchQueue.main.async {
                self.updateRenderView()
            }
        }
    }
    
    // Remote user cancels publishing flow
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserUnpublishStream userId: String, type: ByteRTCMediaStreamType, reason: ByteRTCStreamRemoveReason) {
        ToastComponents.shared.show(withMessage: "onUserUnpublishStream uid: \(userId)")
        
        if type == .video || type == .both {
            
            // Remove from self.users
            var itemsToRemove: [ByteRTCRemoteStreamKey] = []
            
            for streamKey in self.users {
                if streamKey.userId == userId {
                    itemsToRemove.append(streamKey)
                }
            }
            
            for item in itemsToRemove {
                if let index = self.users.firstIndex(of: item) {
                    self.users.remove(at: index)
                }
            }
            
            DispatchQueue.main.async {
                for videoView in self.containerView.subviews {
                    if let view = videoView as? UserVideoView {
                        let userId = view.userId
                        
                        if userId == userId {
                            view.userId = ""
                        }
                    }
                }
            }
            
            DispatchQueue.main.async {
                self.updateRenderView()
            }
        }
    }
    
    // Remote users join the room
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserJoined userInfo: ByteRTCUserInfo, elapsed: Int) {
        ToastComponents.shared.show(withMessage: "onUserJoined uid: \(userInfo.userId)")
        
    }
    
    // The remote user leaves the room
    func rtcRoom(_ rtcRoom: ByteRTCRoom, onUserLeave uid: String, reason: ByteRTCUserOfflineReason) {
        ToastComponents.shared.show(withMessage: "onUserLeave uid: \(uid)")
        
    }
    
    // Receive SEI information
    func rtcEngine(_ engine: ByteRTCVideo, onSEIMessageReceived remoteStreamKey: ByteRTCRemoteStreamKey, andMessage message: Data) {
       
        
        if let string = String(data: message, encoding: .utf8) {
            ToastComponents.shared.show(withMessage: "onSEIMessageReceived: uid = \(remoteStreamKey.userId ?? ""), data = \(string)")

            self.receivedSEIItem.text = string
        }
    }
    
    // MARK: ByteRTCMixedStreamObserver
    func isSupportClientPushStream() -> Bool {
        return false
    }
    
    // Confluence event callback
    func onMixingEvent(_ event: ByteRTCStreamMixingEvent, taskId: String, error errorCode: ByteRTCStreamMixingErrorCode, mix mixType: ByteRTCMixedStreamType) {
        ToastComponents.shared.show(withMessage: "onMixingEvent:\(event.rawValue) taskId:\(taskId) errorCode:\(errorCode.rawValue) + mixType:\(mixType.rawValue)")
    }
    
}
