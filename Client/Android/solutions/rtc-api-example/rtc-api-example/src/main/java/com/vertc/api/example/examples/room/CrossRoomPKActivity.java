package com.vertc.api.example.examples.room;


import android.os.Bundle;
import android.util.Log;
import android.view.TextureView;

import com.ss.bytertc.engine.RTCRoom;
import com.ss.bytertc.engine.RTCRoomConfig;
import com.ss.bytertc.engine.RTCVideo;
import com.ss.bytertc.engine.UserInfo;
import com.ss.bytertc.engine.VideoCanvas;
import com.ss.bytertc.engine.data.ForwardStreamEventInfo;
import com.ss.bytertc.engine.data.ForwardStreamInfo;
import com.ss.bytertc.engine.data.ForwardStreamStateInfo;
import com.ss.bytertc.engine.data.StreamIndex;
import com.ss.bytertc.engine.handler.IRTCRoomEventHandler;
import com.ss.bytertc.engine.handler.IRTCVideoEventHandler;
import com.ss.bytertc.engine.type.ChannelProfile;
import com.ss.bytertc.engine.type.RTCRoomStats;
import com.vertc.api.example.R;
import com.vertc.api.example.base.ExampleBaseActivity;
import com.vertc.api.example.base.ExampleCategory;
import com.vertc.api.example.base.annotation.ApiExample;
import com.vertc.api.example.databinding.ActivityCrossRoomPkBinding;
import com.vertc.api.example.utils.IMEUtils;
import com.vertc.api.example.utils.RTCHelper;
import com.vertc.api.example.utils.ToastUtil;

import java.util.Collections;
import java.util.Locale;

/**
 * <pre>
 * Function name: BytePlusRTC forward stream across rooms.
 * Function brief: The media streams of visible users can be simultaneously forwarded to multiple RTC rooms. There are no restrictions on the number of target rooms for media forwarding.
 * Notes:
 *   1. For demonstration purposes, all tokens for the functionalities are generated by the client-side TokenGenerator class. However, please adjust accordingly based on the specific circumstances when integrating in a real environment.
 * Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-104398
 * </pre>
 */
@ApiExample(title = "Cross room PK", category = ExampleCategory.AUDIO_VIDEO_TRANSMISSION, order = 1)
public class CrossRoomPKActivity extends ExampleBaseActivity {

    private static final String TAG = "CrossRoomPK";

    RTCVideo rtcVideo;
    RTCRoom rtcRoom;

    ActivityCrossRoomPkBinding binding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = ActivityCrossRoomPkBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        binding.getRoot().setOnClickListener(IMEUtils::closeIME);

        binding.btnJoinRoom.setOnClickListener(v -> {
            if (v.isSelected()) {
                leaveRoom();
                v.setSelected(false);
                binding.btnJoinRoom.setText(R.string.button_join_room);
                return;
            }
            String roomId = binding.mainRoomInput.getText().toString();
            if (!RTCHelper.checkValid(roomId)) {
                ToastUtil.showToast(this, R.string.toast_check_valid_false);
                return;
            }
            joinRoom(roomId);
            v.setSelected(true);
            binding.btnJoinRoom.setText(R.string.button_leave_room);
        });

        binding.btnStartTransmit.setOnClickListener(v -> {
            if (rtcRoom == null) {
                return;
            }
            String roomId = binding.transmitRoomInput.getText().toString();
            startForwardStreamToRooms(roomId);
        });

        binding.btnUpdateTransmit.setOnClickListener(v -> {
            if (rtcRoom == null) {
                return;
            }
            String roomId = binding.transmitRoomInput.getText().toString();
            updateForwardStreamToRooms(roomId);
        });

        binding.btnStopTransmit.setOnClickListener(v -> {
            if (rtcRoom != null) {
                rtcRoom.stopForwardStreamToRooms();
            }
        });

        binding.btnPauseTransmit.setOnClickListener(v -> {
            if (rtcRoom != null) {
                rtcRoom.pauseForwardStreamToAllRooms();
            }
        });

        binding.btnResumeTransmit.setOnClickListener(v -> {
            if (rtcRoom != null) {
                rtcRoom.resumeForwardStreamToAllRooms();
            }
        });

        rtcVideo = RTCHelper.createRTCVideo(this, videoEventHandler, "cross-room-pk");
        setLocalRenderView();
        rtcVideo.startVideoCapture();
        rtcVideo.startAudioCapture();
    }

    private void setLocalRenderView() {
        TextureView textureView = new TextureView(this);
        binding.localViewContainer.removeAllViews();
        binding.localViewContainer.addView(textureView);

        VideoCanvas videoCanvas = new VideoCanvas();
        videoCanvas.renderView = textureView;
        videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
        rtcVideo.setLocalVideoCanvas(StreamIndex.STREAM_INDEX_MAIN, videoCanvas);
    }

    private void joinRoom(String roomId) {
        requestRoomToken(roomId, localUid, token -> {
            rtcRoom = rtcVideo.createRTCRoom(roomId);
            rtcRoom.setRTCRoomEventHandler(roomEventHandler);
            UserInfo userInfo = new UserInfo(localUid, "");
            boolean isAutoPublish = true;
            boolean isAutoSubscribeAudio = true;
            boolean isAutoSubscribeVideo = true;
            RTCRoomConfig roomConfig = new RTCRoomConfig(
                    ChannelProfile.CHANNEL_PROFILE_CHAT_ROOM,
                    isAutoPublish,
                    isAutoSubscribeAudio,
                    isAutoSubscribeVideo);
            rtcRoom.joinRoom(token, userInfo, roomConfig);
        });
    }

    private void leaveRoom() {
        if (rtcRoom != null) {
            rtcRoom.leaveRoom();
            rtcRoom.destroy();
            rtcRoom = null;
        }
    }

    private void startForwardStreamToRooms(String roomId) {
        if (!RTCHelper.checkValid(roomId)) {
            ToastUtil.showToast(this, R.string.toast_check_valid_false);
            return;
        }

        requestRoomToken(roomId, localUid, token -> {
            ForwardStreamInfo forwardStreamInfo = new ForwardStreamInfo(roomId, token);
            if (rtcRoom != null) {
                rtcRoom.startForwardStreamToRooms(Collections.singletonList(forwardStreamInfo));
            }
        });
    }

    private void updateForwardStreamToRooms(String roomId) {
        if (!RTCHelper.checkValid(roomId)) {
            ToastUtil.showToast(this, R.string.toast_check_valid_false);
            return;
        }

        requestRoomToken(roomId, localUid, token -> {
            ForwardStreamInfo forwardStreamInfo = new ForwardStreamInfo(roomId, token);
            if (rtcRoom != null) {
                rtcRoom.updateForwardStreamToRooms(Collections.singletonList(forwardStreamInfo));
            }
        });
    }


    IRTCRoomEventHandler roomEventHandler = new IRTCRoomEventHandler() {
        @Override
        public void onRoomStateChanged(String roomId, String uid, int state, String extraInfo) {
            super.onRoomStateChanged(roomId, uid, state, extraInfo);
            String info = String.format(Locale.ENGLISH, "roomId:%s, uid:%s, state:%d, extraInfo:%s", roomId, uid, state, extraInfo);
            ToastUtil.showLongToast(CrossRoomPKActivity.this, info);
            Log.d(TAG, "onRoomStateChanged: " + info);
        }

        @Override
        public void onForwardStreamEvent(ForwardStreamEventInfo[] eventInfos) {
            super.onForwardStreamEvent(eventInfos);
            ForwardStreamEventInfo first = eventInfos[0];
            String msg = String.format(Locale.ENGLISH, "ForwardStreamEvent, roomId:%s, event:%s", first.roomId, first.event);
            ToastUtil.showLongToast(CrossRoomPKActivity.this, msg);

            for (int i = 0; i < eventInfos.length; i++) {
                ForwardStreamEventInfo info = eventInfos[i];
                Log.d(TAG, String.format(Locale.ENGLISH, "onForwardStreamEvent:[index:%d, roomId:%s, event:%s]", i, info.roomId, info.event));
            }
        }

        @Override
        public void onForwardStreamStateChanged(ForwardStreamStateInfo[] stateInfos) {
            super.onForwardStreamStateChanged(stateInfos);
            ForwardStreamStateInfo first = stateInfos[0];
            String msg = String.format(Locale.ENGLISH, "ForwardStreamStateChanged, roomid:%s, state:%s", first.roomId, first.state);
            ToastUtil.showLongToast(CrossRoomPKActivity.this, msg);

            for (int i = 0; i < stateInfos.length; i++) {
                ForwardStreamStateInfo info = stateInfos[i];
                Log.d(TAG, String.format(Locale.ENGLISH, "onForwardStreamStateChanged:[index:%d, roomId:%s, event:%s]", i, info.roomId, info.state));
            }
        }

        @Override
        public void onLeaveRoom(RTCRoomStats stats) {
            super.onLeaveRoom(stats);
            ToastUtil.showLongToast(CrossRoomPKActivity.this, "onLeaveRoom, stats:" + stats);

            Log.d(TAG, "onLeaveRoom: " + stats);
        }

        @Override
        public void onUserJoined(UserInfo userInfo, int elapsed) {
            super.onUserJoined(userInfo, elapsed);
            ToastUtil.showToast(CrossRoomPKActivity.this, "onUserJoined, uid:" + userInfo.getUid());

            Log.d(TAG, "onUserJoined: " + userInfo.getUid());
        }
    };

    IRTCVideoEventHandler videoEventHandler = new IRTCVideoEventHandler() {
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();
        leaveRoom();
        if (rtcVideo != null) {
            rtcVideo.stopAudioCapture();
            rtcVideo.stopVideoCapture();
        }
        RTCVideo.destroyRTCVideo();
        rtcVideo = null;
    }
}