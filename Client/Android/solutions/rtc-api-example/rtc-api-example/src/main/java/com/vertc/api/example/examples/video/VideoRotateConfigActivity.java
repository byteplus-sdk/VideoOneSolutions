package com.vertc.api.example.examples.video;

import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;
import android.view.TextureView;
import android.view.View;
import android.widget.AdapterView;
import android.widget.FrameLayout;

import androidx.annotation.NonNull;
import androidx.lifecycle.ViewModelProvider;

import com.ss.bytertc.base.media.Size;
import com.ss.bytertc.engine.RTCRoom;
import com.ss.bytertc.engine.RTCRoomConfig;
import com.ss.bytertc.engine.RTCVideo;
import com.ss.bytertc.engine.UserInfo;
import com.ss.bytertc.engine.VideoCanvas;
import com.ss.bytertc.engine.data.RemoteStreamKey;
import com.ss.bytertc.engine.data.StreamIndex;
import com.ss.bytertc.engine.data.VideoOrientation;
import com.ss.bytertc.engine.data.VideoRotationMode;
import com.ss.bytertc.engine.handler.IRTCRoomEventHandler;
import com.ss.bytertc.engine.handler.IRTCVideoEventHandler;
import com.ss.bytertc.engine.type.ChannelProfile;
import com.ss.bytertc.engine.type.MediaStreamType;
import com.ss.bytertc.engine.type.RTCRoomStats;
import com.ss.bytertc.engine.type.StreamRemoveReason;
import com.ss.bytertc.engine.video.ByteWatermark;
import com.ss.bytertc.engine.video.RTCWatermarkConfig;
import com.vertc.api.example.R;
import com.vertc.api.example.adapter.OnItemSelectedAdapter;
import com.vertc.api.example.base.ExampleBaseActivity;
import com.vertc.api.example.base.ExampleCategory;
import com.vertc.api.example.base.annotation.ApiExample;
import com.vertc.api.example.databinding.ActivityVideoRotateConfigBinding;
import com.vertc.api.example.utils.IMEUtils;
import com.vertc.api.example.utils.RTCHelper;
import com.vertc.api.example.utils.ToastUtil;

import java.util.Locale;
import java.util.Objects;

/**
 * <pre>
 * Function name: BytePlusRTC video rotation.
 * Function brief: Modify common video parameters such as rotation and video orientation.
 * Notes:
 *   1. For demonstration purposes, all tokens for the functionalities are generated by the client-side TokenGenerator class. However, please adjust accordingly based on the specific circumstances when integrating in a real environment.
 * Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-106458
 * </pre>
 */
@ApiExample(title = "Video rotation", category = ExampleCategory.VIDEO, order = 3)
public class VideoRotateConfigActivity extends ExampleBaseActivity {

    private static final String TAG = "VideoRotateConfig";

    ActivityVideoRotateConfigBinding binding;

    VideoRotateConfigViewModel viewModel;

    @NonNull
    private RTCVideo getRTCVideo() {
        return Objects.requireNonNull(viewModel.rtcVideo);
    }

    @NonNull
    private String getRoomId() {
        return Objects.requireNonNull(viewModel.roomId);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        viewModel = new ViewModelProvider(this).get(VideoRotateConfigViewModel.class);

        binding = ActivityVideoRotateConfigBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        binding.content.setOnClickListener(IMEUtils::closeIME);

        initUI(binding);

        if (viewModel.rtcVideo == null) {
            viewModel.rtcVideo = RTCHelper.createRTCVideo(this, rtcVideoEventHandler, "video-config-rotate");
            getRTCVideo().startVideoCapture();
            getRTCVideo().startAudioCapture();
        }

        setLocalRenderView();

        String remoteUserId = viewModel.remoteUserId;
        if (remoteUserId != null) {
            setRemoteRenderView(remoteUserId);
        }

        binding.btnJoinRoom.setOnClickListener(v -> {
            if (viewModel.isJoined) {
                viewModel.leaveRoom();

                viewModel.isJoined = false;
                binding.btnJoinRoom.setText(R.string.button_join_room);
                return;
            }
            String roomId = binding.roomIdInput.getText().toString();
            if (!RTCHelper.checkValid(roomId)) {
                ToastUtil.showToast(this, R.string.toast_check_valid_false);
                return;
            }
            joinRoom(roomId);
            viewModel.isJoined = true;
            binding.btnJoinRoom.setText(R.string.button_leave_room);
        });

        binding.btnJoinRoom.setText(viewModel.isJoined ?
                R.string.button_leave_room : R.string.button_join_room
        );
    }

    private void initUI(ActivityVideoRotateConfigBinding binding) {
        binding.videoOrientationSpinner.setOnItemSelectedListener(new OnItemSelectedAdapter() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                RTCVideo rtcVideo = getRTCVideo();
                String item = (String) binding.videoOrientationSpinner.getSelectedItem();
                switch (item) {
                    case "Adaptive":
                        rtcVideo.setVideoOrientation(VideoOrientation.ADAPTIVE);
                        break;
                    case "Portrait":
                        rtcVideo.setVideoOrientation(VideoOrientation.PORTRAIT);
                        break;
                    case "Landscape":
                        rtcVideo.setVideoOrientation(VideoOrientation.LANDSCAPE);
                        break;
                }
            }
        });
        binding.videoRotationModeSpinner.setOnItemSelectedListener(new OnItemSelectedAdapter() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                RTCVideo rtcVideo = getRTCVideo();
                String item = (String) binding.videoRotationModeSpinner.getSelectedItem();
                switch (item) {
                    case "FollowApp":
                        rtcVideo.setVideoRotationMode(VideoRotationMode.FOLLOW_APP);
                        break;
                    case "FollowGSensor":
                        rtcVideo.setVideoRotationMode(VideoRotationMode.FOLLOW_GSENSOR);
                        break;
                }
            }
        });

        binding.btnAddWatermark.setOnClickListener(v -> addWatermark());
        binding.btnClearWatermark.setOnClickListener(v -> clearWatermark());
    }

    /**
     * @param roomId RTC roomId
     */
    private void joinRoom(String roomId) {
        viewModel.roomId = roomId;
        requestRoomToken(roomId, localUid, token -> {
            RTCRoom rtcRoom = getRTCVideo().createRTCRoom(roomId);
            viewModel.setRtcRoom(rtcRoom);
            rtcRoom.setRTCRoomEventHandler(new RTCRoomEventHandler(this));
            UserInfo userInfo = new UserInfo(localUid, "");
            boolean isAutoPublish = true;
            boolean isAutoSubscribeAudio = true;
            boolean isAutoSubscribeVideo = true;
            RTCRoomConfig roomConfig = new RTCRoomConfig(
                    ChannelProfile.CHANNEL_PROFILE_CHAT_ROOM,
                    isAutoPublish,
                    isAutoSubscribeAudio,
                    isAutoSubscribeVideo);
            rtcRoom.joinRoom(token, userInfo, roomConfig);
        });
    }

    private void setLocalRenderView() {
        TextureView textureView = new TextureView(this);
        binding.localViewContainer.removeAllViews();
        binding.localViewContainer.addView(textureView);

        VideoCanvas videoCanvas = new VideoCanvas();
        videoCanvas.renderView = textureView;
        videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
        getRTCVideo().setLocalVideoCanvas(StreamIndex.STREAM_INDEX_MAIN, videoCanvas);
    }

    private void onUserPublishStream(String uid) {
        runOnUiThread(() -> {
            if (viewModel.remoteUserId == null) {
                viewModel.remoteUserId = uid;
                setRemoteRenderView(uid);
            }
        });
    }

    private void setRemoteRenderView(String uid) {
        TextureView textureView = new TextureView(this);

        binding.remoteViewContainer.removeAllViews();

        binding.remoteViewContainer.addView(textureView,
                new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));

        VideoCanvas videoCanvas = new VideoCanvas();
        videoCanvas.renderView = textureView;
        videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;

        RemoteStreamKey remoteStreamKey = new RemoteStreamKey(getRoomId(), uid, StreamIndex.STREAM_INDEX_MAIN);
        getRTCVideo().setRemoteVideoCanvas(remoteStreamKey, videoCanvas);
    }

    private void onUserUnpublishStream(String uid) {
        runOnUiThread(() -> {
            if (TextUtils.equals(uid, viewModel.remoteUserId)) {
                viewModel.remoteUserId = null;
                removeRemoteView(uid);
            }
        });
    }

    private void removeRemoteView(String uid) {
        binding.remoteViewContainer.removeAllViews();
        RemoteStreamKey remoteStreamKey = new RemoteStreamKey(getRoomId(), uid, StreamIndex.STREAM_INDEX_MAIN);
        getRTCVideo().setRemoteVideoCanvas(remoteStreamKey, null);
    }

    private void addWatermark() {
        String path = "/assets/watermark.jpg";

        Size imageSize = new Size(513, 102);
        Size videoSize = new Size(720, 1280);

        float x = (1.F - ((float) imageSize.width / videoSize.width)) / 2.F;

        ByteWatermark byteWatermark = new ByteWatermark(x, 0.2F,
                (float) imageSize.width / videoSize.width,
                (float) imageSize.height / videoSize.height);
        RTCWatermarkConfig config = new RTCWatermarkConfig(true, byteWatermark, byteWatermark);
        getRTCVideo().setVideoWatermark(StreamIndex.STREAM_INDEX_MAIN, path, config);
    }

    private void clearWatermark() {
        getRTCVideo().clearVideoWatermark(StreamIndex.STREAM_INDEX_MAIN);
    }

    IRTCVideoEventHandler rtcVideoEventHandler = new IRTCVideoEventHandler() {
    };

    @Override
    protected void onDestroy() {
        Log.d(TAG, "onDestroy: ");
        super.onDestroy();
        if (!isChangingConfigurations()) {
            viewModel.destroy();
        }
    }

    static class RTCRoomEventHandler extends IRTCRoomEventHandler {
        private final VideoRotateConfigActivity mParent;

        public RTCRoomEventHandler(VideoRotateConfigActivity parent) {
            mParent = parent;
        }

        @Override
        public void onRoomStateChanged(String roomId, String uid, int state, String extraInfo) {
            super.onRoomStateChanged(roomId, uid, state, extraInfo);
            String info = String.format(Locale.ENGLISH, "roomId:%s, uid:%s, state:%d, extraInfo:%s", roomId, uid, state, extraInfo);
            ToastUtil.showToast(mParent, info);
        }

        @Override
        public void onUserPublishStream(String uid, MediaStreamType type) {
            super.onUserPublishStream(uid, type);
            if (MediaStreamType.RTC_MEDIA_STREAM_TYPE_VIDEO == type || MediaStreamType.RTC_MEDIA_STREAM_TYPE_BOTH == type) {
                mParent.onUserPublishStream(uid);
            }
        }

        @Override
        public void onUserUnpublishStream(String uid, MediaStreamType type, StreamRemoveReason reason) {
            super.onUserUnpublishStream(uid, type, reason);
            if (MediaStreamType.RTC_MEDIA_STREAM_TYPE_VIDEO == type || MediaStreamType.RTC_MEDIA_STREAM_TYPE_BOTH == type) {
                mParent.onUserUnpublishStream(uid);
            }
        }

        @Override
        public void onUserJoined(UserInfo userInfo, int elapsed) {
            super.onUserJoined(userInfo, elapsed);
            ToastUtil.showToast(mParent, "onUserJoined, uid:" + userInfo.getUid());
        }

        @Override
        public void onLeaveRoom(RTCRoomStats stats) {
            super.onLeaveRoom(stats);
            ToastUtil.showLongToast(mParent, "onLeaveRoom, stats:" + stats.toString());
        }
    }
}