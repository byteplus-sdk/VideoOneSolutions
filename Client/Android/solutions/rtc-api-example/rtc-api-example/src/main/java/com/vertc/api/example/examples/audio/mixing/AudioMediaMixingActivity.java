package com.vertc.api.example.examples.audio.mixing;

import android.annotation.SuppressLint;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;
import android.view.TextureView;
import android.view.View;
import android.widget.AdapterView;

import androidx.annotation.NonNull;

import com.google.android.material.slider.Slider;
import com.ss.bytertc.engine.IMediaPlayerEventHandler;
import com.ss.bytertc.engine.RTCRoom;
import com.ss.bytertc.engine.RTCRoomConfig;
import com.ss.bytertc.engine.RTCVideo;
import com.ss.bytertc.engine.UserInfo;
import com.ss.bytertc.engine.VideoCanvas;
import com.ss.bytertc.engine.audio.IMediaPlayer;
import com.ss.bytertc.engine.data.AudioChannel;
import com.ss.bytertc.engine.data.AudioMixingDualMonoMode;
import com.ss.bytertc.engine.data.AudioMixingType;
import com.ss.bytertc.engine.data.AudioSampleRate;
import com.ss.bytertc.engine.data.MediaPlayerConfig;
import com.ss.bytertc.engine.data.MediaPlayerCustomSource;
import com.ss.bytertc.engine.data.MediaPlayerCustomSourceMode;
import com.ss.bytertc.engine.data.MediaPlayerCustomSourceStreamType;
import com.ss.bytertc.engine.data.PlayerError;
import com.ss.bytertc.engine.data.PlayerState;
import com.ss.bytertc.engine.data.StreamIndex;
import com.ss.bytertc.engine.handler.IRTCRoomEventHandler;
import com.ss.bytertc.engine.handler.IRTCVideoEventHandler;
import com.ss.bytertc.engine.type.ChannelProfile;
import com.ss.bytertc.engine.type.RTCRoomStats;
import com.ss.bytertc.engine.utils.AudioFrame;
import com.vertc.api.example.R;
import com.vertc.api.example.adapter.OnItemSelectedAdapter;
import com.vertc.api.example.base.ExampleBaseActivity;
import com.vertc.api.example.base.ExampleCategory;
import com.vertc.api.example.base.annotation.ApiExample;
import com.vertc.api.example.databinding.ActivityAudioMediaMixingBinding;
import com.vertc.api.example.utils.FileUtils;
import com.vertc.api.example.utils.IMEUtils;
import com.vertc.api.example.utils.RTCHelper;
import com.vertc.api.example.utils.ToastUtil;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.Locale;
import java.util.Timer;
import java.util.TimerTask;

/**
 * <pre>
 * Function name: BytePlusRTC music mixing.
 * Function brief: If you need to play music files during a call and ensure that all members in the room can hear the audio, you will need to use the audio mixing function. This function can combine the audio data captured by the microphone with audio files, PCM audio data, etc. into a single audio stream. The mixed audio stream is then published within the room, allowing all members to hear the combined audio during the call.
 * Notes:
 *   1. For demonstration purposes, all tokens for the functionalities are generated by the client-side TokenGenerator class. However, please adjust accordingly based on the specific circumstances when integrating in a real environment.
 * Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-70141
 * </pre>
 */
@ApiExample(title = "Audio music mixing", category = ExampleCategory.AUDIO, order = 3)
public class AudioMediaMixingActivity extends ExampleBaseActivity {

    private static final String TAG = "MediaMixingActivity";

    private RTCVideo rtcVideo;
    private RTCRoom rtcRoom;
    private IMediaPlayer mediaPlayer;
    private IMediaPlayer pcmPlayer;

    private static final int PLAYER_ID_1 = 0;
    private static final int PLAYER_ID_PCM = 1;

    private static final String path1 = "/assets/rtc_audio.m4a";
    private static final String pcmPath = "/assets/rtc_audio_16k_mono.pcm";

    private byte[] fileData = null;
    private int fileDataOffset = 0;
    private int fileDataBufferSize = 0;

    private Timer mPCMTimer;
    private TimerTask mPCMTask;
    private boolean isFirstPush = true;

    ActivityAudioMediaMixingBinding binding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = ActivityAudioMediaMixingBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        binding.content.setOnClickListener(IMEUtils::closeIME);

        initUI(binding);

        rtcVideo = RTCHelper.createRTCVideo(this, rtcVideoEventHandler, "audio-media-mixing");
        rtcVideo.startAudioCapture();
        rtcVideo.startVideoCapture();
        setLocalRenderView();
        pcmPlayer = rtcVideo.getMediaPlayer(PLAYER_ID_PCM);
        mediaPlayer = rtcVideo.getMediaPlayer(PLAYER_ID_1);

        mediaPlayer.setEventHandler(mediaPlayerEventHandler);
        pcmPlayer.setEventHandler(pcmPlayerEventHandler);

        mPCMTimer = new Timer("rtc-pcm-push-timer");
    }

    private boolean isProgressTrackingTouch = false;

    private void initUI(ActivityAudioMediaMixingBinding binding) {
        binding.btnJoinRoom.setOnClickListener(v -> {

            if (v.isSelected()) {
                leaveRoom();

                v.setSelected(false);
                binding.btnJoinRoom.setText(R.string.button_join_room);
                return;
            }
            String roomId = binding.roomIdInput.getText().toString();
            if (!RTCHelper.checkValid(roomId)) {
                ToastUtil.showToast(this, R.string.toast_check_valid_false);
                return;
            }
            joinRoom(roomId);
            v.setSelected(true);
            binding.btnJoinRoom.setText(R.string.button_leave_room);
        });

        // region Media Mixing
        binding.fileMixing.resInput.setText(path1);
        binding.fileMixing.btnOpen.setOnClickListener(v -> openMedia(path1));
        binding.fileMixing.btnPlay.setOnClickListener(v -> mediaPlayer.start());
        binding.fileMixing.btnStop.setOnClickListener(v -> mediaPlayer.stop());
        binding.fileMixing.btnPause.setOnClickListener(v -> mediaPlayer.pause());
        binding.fileMixing.btnResume.setOnClickListener(v -> mediaPlayer.resume());
        binding.fileMixing.volumeBar.addOnChangeListener((slider, value, fromUser) -> {
            int volume = (int) value;
            mediaPlayer.setVolume(volume, AudioMixingType.AUDIO_MIXING_TYPE_PLAYOUT_AND_PUBLISH);
            binding.fileMixing.volumeText.setText(String.valueOf(volume));
        });
        binding.fileMixing.progress.addOnSliderTouchListener(new Slider.OnSliderTouchListener() {
            @SuppressLint("RestrictedApi")
            @Override
            public void onStartTrackingTouch(@NonNull Slider slider) {
                isProgressTrackingTouch = true;
            }

            @SuppressLint("RestrictedApi")
            @Override
            public void onStopTrackingTouch(@NonNull Slider slider) {
                isProgressTrackingTouch = false;
                float value = slider.getValue();
                mediaPlayer.setPosition((int) value);
            }
        });
        binding.fileMixing.btnSetAudioTrack.setOnClickListener(v -> {
            String audioTrack = binding.fileMixing.audioTrackInput.getText().toString();
            if (TextUtils.isEmpty(audioTrack)) {
                ToastUtil.showLongToast(this, R.string.toast_input_is_empty);
                return;
            }
            mediaPlayer.selectAudioTrack(Integer.parseInt(audioTrack));
        });
        binding.fileMixing.voicePitchBar.addOnChangeListener((slider, value, fromUser) -> {
            // Audio Pitch Range = [-12, 12]
            int audioPitch = (int) value;
            binding.fileMixing.voicePitchText.setText(String.valueOf(audioPitch));
            if (fromUser) {
                mediaPlayer.setAudioPitch(audioPitch);
            }
        });
        binding.fileMixing.voiceSpeedBar.addOnChangeListener((slider, value, fromUser) -> {
            // Playback Speed Range = [50, 200]
            int playbackSpeed = (int) value;
            binding.fileMixing.voiceSpeedText.setText(String.valueOf(playbackSpeed));
            if (fromUser) {
                mediaPlayer.setPlaybackSpeed(playbackSpeed);
            }
        });
        binding.fileMixing.audioMixingMode.setOnItemSelectedListener(new OnItemSelectedAdapter() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                AudioMixingDualMonoMode mode = AudioMixingDualMonoMode.fromId(position);
                mediaPlayer.setAudioDualMonoMode(mode);
            }
        });

        // endregion

        // region PCM MIXING
        binding.pcmMixing.resPcm.setText(pcmPath);
        binding.pcmMixing.btnPlay.setOnClickListener(v -> startPlayPCM());
        binding.pcmMixing.btnStop.setOnClickListener(v -> stopPlayPCM());
        binding.pcmMixing.btnPause.setOnClickListener(v -> stopPushPCM());
        binding.pcmMixing.btnResume.setOnClickListener(v -> startPushPCM());
        binding.pcmMixing.volumeBar.addOnChangeListener((slider, value, fromUser) -> {
            int volume = (int) value;
            pcmPlayer.setVolume(volume, AudioMixingType.AUDIO_MIXING_TYPE_PLAYOUT_AND_PUBLISH);
            binding.pcmMixing.volumeText.setText(String.valueOf(volume));
        });
        // endregion
    }

    private void setLocalRenderView() {
        TextureView textureView = new TextureView(this);
        binding.localViewContainer.removeAllViews();
        binding.localViewContainer.addView(textureView);

        VideoCanvas videoCanvas = new VideoCanvas();
        videoCanvas.renderView = textureView;
        videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
        rtcVideo.setLocalVideoCanvas(StreamIndex.STREAM_INDEX_MAIN, videoCanvas);
    }


    private void openMedia(String filePath) {
        MediaPlayerConfig playerConfig = new MediaPlayerConfig();
        playerConfig.startPos = 0;
        playerConfig.autoPlay = false;
        playerConfig.playCount = 1;
        playerConfig.type = AudioMixingType.AUDIO_MIXING_TYPE_PLAYOUT_AND_PUBLISH;
        playerConfig.callbackOnProgressInterval = 500;
        mediaPlayer.open(filePath, playerConfig);
    }

    private void startPlayPCM() {
        openFile(pcmPath);

        MediaPlayerCustomSource source = new MediaPlayerCustomSource();
        source.mode = MediaPlayerCustomSourceMode.PUSH;
        source.type = MediaPlayerCustomSourceStreamType.RAW;
        source.provider = null;

        MediaPlayerConfig playerConfig = new MediaPlayerConfig();
        playerConfig.startPos = 0;
        playerConfig.autoPlay = true;
        playerConfig.playCount = 1;
        playerConfig.type = AudioMixingType.AUDIO_MIXING_TYPE_PLAYOUT_AND_PUBLISH;
        playerConfig.callbackOnProgressInterval = 500;

        pcmPlayer.openWithCustomSource(source, playerConfig);
        startPushPCM();
    }

    private void stopPlayPCM() {
        stopPushPCM();
        pcmPlayer.stop();
        fileDataOffset = 0;
        isFirstPush = true;
    }

    private void stopPushPCM() {
        if (mPCMTask != null) {
            mPCMTask.cancel();
            mPCMTask = null;
        }
    }

    private void startPushPCM() {
        if (mPCMTask == null) {
            mPCMTask = new PCMTimerTask();
            mPCMTimer.scheduleAtFixedRate(mPCMTask, 10, 10);
        }
    }

    class PCMTimerTask extends TimerTask {
        @Override
        public void run() {
            int size = 16 * 10;
            if (isFirstPush) {
                size = size * 20;
                isFirstPush = false;
            }
            ByteBuffer pushBuffer = ByteBuffer.allocate(size * 2);
            AudioFrame audioFrame = new AudioFrame();
            audioFrame.channel = AudioChannel.AUDIO_CHANNEL_MONO;
            audioFrame.sampleRate = AudioSampleRate.AUDIO_SAMPLE_RATE_16000;
            audioFrame.samples = size;

            int nRead = 0;
            if (fileData != null) {
                nRead = Integer.min(size * 2, fileDataBufferSize - fileDataOffset);
                pushBuffer.put(fileData, fileDataOffset, nRead);
                fileDataOffset += nRead;
            }
            Log.i(TAG, "offset:" + fileDataOffset + " read:" + nRead);
            if (nRead == 0) {
                stopPlayPCM();
                return;
            }
            audioFrame.buffer = pushBuffer.array();
            pcmPlayer.pushExternalAudioFrame(audioFrame);
        }
    }

    private int openFile(String filePath) {
        try (InputStream in = FileUtils.openFile(this, filePath)) {
            ByteArrayOutputStream bos = new ByteArrayOutputStream(8192);
            byte[] buffer = new byte[4096];
            int read;

            while ((read = in.read(buffer)) > 0) {
                bos.write(buffer, 0, read);
            }

            fileData = bos.toByteArray();
            fileDataBufferSize = bos.size();
            Log.i(TAG, "init success mFileSize=" + fileDataBufferSize + ", this =" + this);

            return 0;
        } catch (IOException e) {
            e.printStackTrace();
            return -1;
        }
    }

    private void joinRoom(String roomId) {
        requestRoomToken(roomId, localUid, token -> {
            rtcRoom = rtcVideo.createRTCRoom(roomId);
            rtcRoom.setRTCRoomEventHandler(rtcRoomEventHandler);
            UserInfo userInfo = new UserInfo(localUid, "");
            boolean isAutoPublish = true;
            boolean isAutoSubscribeAudio = true;
            boolean isAutoSubscribeVideo = true;
            RTCRoomConfig roomConfig = new RTCRoomConfig(
                    ChannelProfile.CHANNEL_PROFILE_CHAT_ROOM,
                    isAutoPublish,
                    isAutoSubscribeAudio,
                    isAutoSubscribeVideo);
            rtcRoom.joinRoom(token, userInfo, roomConfig);
        });
    }

    private void leaveRoom() {
        if (rtcRoom != null) {
            rtcRoom.leaveRoom();
            rtcRoom.destroy();
            rtcRoom = null;
        }
    }

    final IMediaPlayerEventHandler mediaPlayerEventHandler = new IMediaPlayerEventHandler() {
        @Override
        public void onMediaPlayerStateChanged(int playerId, PlayerState state, PlayerError error) {
            String msg = String.format(Locale.ENGLISH, "onMediaPlayerStateChanged, playerId:%d, state:%s, error:%s", playerId, state, error);
            Log.d(TAG, msg);
            ToastUtil.showToast(AudioMediaMixingActivity.this, msg);
            runOnUiThread(() -> {
                if (state == PlayerState.PLAYING && error == PlayerError.OK) {
                    int duration = mediaPlayer.getTotalDuration();
                    binding.fileMixing.labelTotalTimeLength.setText(String.valueOf(duration));
                    binding.fileMixing.progress.setValueTo(duration);
                    binding.fileMixing.progress.setEnabled(true);

                    binding.fileMixing.labelTotalTrackCount.setText(
                            getString(R.string.label_hint_track_xxx, mediaPlayer.getAudioTrackCount()));
                } else if ((state == PlayerState.OPENED || state == PlayerState.STOPPED)
                        && error == PlayerError.OK) {
                    // reset to default views
                    binding.fileMixing.labelTotalTrackCount.setText(
                            getString(R.string.label_hint_track_xxx, 0));


                    binding.fileMixing.labelCurrentProgress.setText(String.valueOf(0));
                    binding.fileMixing.labelTotalTimeLength.setText(String.valueOf(100));
                    binding.fileMixing.progress.setValueTo(100);
                    binding.fileMixing.progress.setValue(0);
                    binding.fileMixing.progress.setEnabled(false);

                    binding.fileMixing.voicePitchBar.setValue(0);
                    binding.fileMixing.voiceSpeedBar.setValue(100);
                    binding.fileMixing.audioMixingMode.setSelection(0);
                }
            });
        }

        @Override
        public void onMediaPlayerPlayingProgress(int playerId, long progress) {
            Log.d(TAG, "onMediaPlayerPlayingProgress, playerId:" + playerId + " progress:" + progress);
            runOnUiThread(() -> {
                if (!isProgressTrackingTouch) {
                    binding.fileMixing.progress.setValue(progress);
                }
                binding.fileMixing.labelCurrentProgress.setText(String.valueOf(progress));
            });
        }
    };

    final IMediaPlayerEventHandler pcmPlayerEventHandler = new IMediaPlayerEventHandler() {
        @Override
        public void onMediaPlayerStateChanged(int playerId, PlayerState state, PlayerError error) {
            String msg = String.format(Locale.ENGLISH, "[PCM]onMediaPlayerStateChanged, playerId:%d, state:%s, error:%s", playerId, state, error);
            ToastUtil.showToast(AudioMediaMixingActivity.this, msg);
        }

        @Override
        public void onMediaPlayerPlayingProgress(int playerId, long progress) {
            Log.d(TAG, "[PCM]onMediaPlayerPlayingProgress, playerId:" + playerId + " progress:" + progress);
        }
    };

    IRTCVideoEventHandler rtcVideoEventHandler = new IRTCVideoEventHandler() {
    };

    IRTCRoomEventHandler rtcRoomEventHandler = new IRTCRoomEventHandler() {
        @Override
        public void onRoomStateChanged(String roomId, String uid, int state, String extraInfo) {
            super.onRoomStateChanged(roomId, uid, state, extraInfo);
            String info = String.format(Locale.ENGLISH, "onRoomStateChanged,roomId:%s, uid:%s, state:%d, extraInfo:%s", roomId, uid, state, extraInfo);
            ToastUtil.showLongToast(AudioMediaMixingActivity.this, info);
        }

        @Override
        public void onLeaveRoom(RTCRoomStats stats) {
            super.onLeaveRoom(stats);
            ToastUtil.showLongToast(AudioMediaMixingActivity.this, "onLeaveRoom, stats:" + stats.toString());
        }

        @Override
        public void onUserJoined(UserInfo userInfo, int elapsed) {
            super.onUserJoined(userInfo, elapsed);
            ToastUtil.showToast(AudioMediaMixingActivity.this, "onUserJoined, uid:" + userInfo.getUid());
        }

        @Override
        public void onUserLeave(String uid, int reason) {
            super.onUserLeave(uid, reason);
            String info = String.format("onUserLeave, uid:%s, reason:%s", uid, reason + "");
            ToastUtil.showLongToast(AudioMediaMixingActivity.this, info);
        }
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mPCMTimer.cancel();
        leaveRoom();
        if (rtcVideo != null) {
            rtcVideo.stopAudioCapture();
            rtcVideo.stopVideoCapture();
        }
        RTCVideo.destroyRTCVideo();
        rtcVideo = null;
    }
}