package com.vertc.api.example.examples.messaging;


import android.graphics.PixelFormat;
import android.os.Bundle;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;
import android.view.TextureView;

import androidx.annotation.NonNull;
import androidx.camera.core.ImageAnalysis;
import androidx.camera.core.ImageInfo;
import androidx.camera.core.ImageProxy;

import com.ss.bytertc.engine.RTCRoom;
import com.ss.bytertc.engine.RTCRoomConfig;
import com.ss.bytertc.engine.RTCVideo;
import com.ss.bytertc.engine.UserInfo;
import com.ss.bytertc.engine.VideoCanvas;
import com.ss.bytertc.engine.data.RemoteStreamKey;
import com.ss.bytertc.engine.data.SEICountPerFrame;
import com.ss.bytertc.engine.data.StreamIndex;
import com.ss.bytertc.engine.data.VideoPixelFormat;
import com.ss.bytertc.engine.data.VideoRotation;
import com.ss.bytertc.engine.data.VideoSourceType;
import com.ss.bytertc.engine.handler.IRTCRoomEventHandler;
import com.ss.bytertc.engine.handler.IRTCVideoEventHandler;
import com.ss.bytertc.engine.live.ByteRTCStreamMixingEvent;
import com.ss.bytertc.engine.live.ByteRTCTranscoderErrorCode;
import com.ss.bytertc.engine.live.IMixedStreamObserver;
import com.ss.bytertc.engine.live.MixedStreamConfig;
import com.ss.bytertc.engine.live.MixedStreamType;
import com.ss.bytertc.engine.type.ChannelProfile;
import com.ss.bytertc.engine.type.RTCRoomStats;
import com.ss.bytertc.engine.video.VideoFrame;
import com.ss.bytertc.engine.video.builder.CpuBufferVideoFrameBuilder;
import com.vertc.api.example.R;
import com.vertc.api.example.base.ExampleBaseActivity;
import com.vertc.api.example.base.ExampleCategory;
import com.vertc.api.example.base.annotation.ApiExample;
import com.vertc.api.example.databinding.ActivitySeimessageBinding;
import com.vertc.api.example.examples.video.customcapture.CameraHelper;
import com.vertc.api.example.utils.IMEUtils;
import com.vertc.api.example.utils.RTCHelper;
import com.vertc.api.example.utils.RTMPLinkGenerator;
import com.vertc.api.example.utils.ToastUtil;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * <pre>
 * Function name: SEI message.
 * Function brief: Sends a SEI message. The SEI data will be added to consecutive "repeatCount + 1" video frames starting from the current frame.
 * Notes:
 *  1. For demonstration purposes, all tokens for the functionalities are generated by the client-side TokenGenerator class. However, please adjust accordingly based on the specific circumstances when integrating in a real environment.
 *  2. In a video call, the SEI data is sent along with the video frames, while in an audio call, the SEI data is sent along with black frames with a resolution of 16 x 16 pixels, which are automatically published by the SDK.
 *  3. In an audio call scenario, this parameter should be set to "ByteRTCStreamIndexMain", otherwise the SEI data will be discarded and cannot be sent to the remote user.
 * </pre>
 */
@ApiExample(title = "SEI messaging", category = ExampleCategory.MESSAGING, order = 1)
public class SEIMessageActivity extends ExampleBaseActivity {

    private static final String TAG = "SEIMessageActivity";

    private RTCVideo rtcVideo;
    private RTCRoom rtcRoom;
    private MixedStreamConfig mixedStreamConfig;
    private String roomID;
    private static final String CDN_TASK_ID = "1";

    ActivitySeimessageBinding binding;

    private ExecutorService executor;
    private CameraHelper cameraHelper;

    private boolean isPushingCustomVideo;
    private String customMessage = "";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = ActivitySeimessageBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        binding.content.setOnClickListener(IMEUtils::closeIME);

        initUI();

        rtcVideo = RTCHelper.createRTCVideo(this, rtcVideoEventHandler, "sei-messaging");
        rtcVideo.startAudioCapture();
        rtcVideo.startVideoCapture();

        mixedStreamConfig = MixedStreamConfig.defaultMixedStreamConfig();

        setLocalRenderView();

        executor = Executors.newSingleThreadExecutor();
        cameraHelper = new CameraHelper(
                ImageAnalysis.OUTPUT_IMAGE_FORMAT_RGBA_8888,
                executor,
                new RTCVideoFrameConsumer()
        );
    }

    private void initUI() {
        binding.pushUrlInput.setText(RTMPLinkGenerator.create(CDN_TASK_ID));

        binding.btnJoinRoom.setOnClickListener(v -> {
            if (v.isSelected()) {
                leaveRoom();

                v.setSelected(false);
                binding.btnJoinRoom.setText(R.string.button_join_room);
                return;
            }
            String roomId = binding.roomIdInput.getText().toString();
            if (!RTCHelper.checkValid(roomId)) {
                ToastUtil.showToast(this, R.string.toast_check_valid_false);
                return;
            }
            joinRoom(roomId);
            v.setSelected(true);
            binding.btnJoinRoom.setText(R.string.button_leave_room);
        });

        binding.btnSendSeiMsg.setOnClickListener(v -> {
            String msg = binding.seiMsgInput.getText().toString();
            if (TextUtils.isEmpty(msg)) {
                ToastUtil.showToast(this, R.string.toast_message_is_empty);
            }

            rtcVideo.sendSEIMessage(StreamIndex.STREAM_INDEX_MAIN, msg.getBytes(StandardCharsets.UTF_8), 3, SEICountPerFrame.SEI_COUNT_PER_FRAME_SINGLE);
        });

        binding.btnStartPush.setOnClickListener(v -> {
            startPushMixedStreamToCDN();
        });

        binding.btnUpdatePush.setOnClickListener(v -> {
            updateCDNStreamConfig();
        });
        binding.btnStopPush.setOnClickListener(v -> {
            stopPushCDNStream();
        });

        binding.btnStartPushFrame.setOnClickListener(v -> {
            startPushCustomVideo();
        });
        binding.btnStopPushFrame.setOnClickListener(v -> {
            stopPushCustomVideo();
        });
    }

    private void setLocalRenderView() {
        TextureView textureView = new TextureView(this);
        binding.localViewContainer.removeAllViews();
        binding.localViewContainer.addView(textureView);

        VideoCanvas videoCanvas = new VideoCanvas();
        videoCanvas.renderView = textureView;
        videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
        rtcVideo.setLocalVideoCanvas(StreamIndex.STREAM_INDEX_MAIN, videoCanvas);
    }

    private void joinRoom(String roomId) {
        requestRoomToken(roomId, localUid, token -> {
            this.roomID = roomId;
            rtcRoom = rtcVideo.createRTCRoom(roomId);
            rtcRoom.setRTCRoomEventHandler(rtcRoomEventHandler);
            UserInfo userInfo = new UserInfo(localUid, "");
            boolean isAutoPublish = true;
            boolean isAutoSubscribeAudio = true;
            boolean isAutoSubscribeVideo = true;
            RTCRoomConfig roomConfig = new RTCRoomConfig(
                    ChannelProfile.CHANNEL_PROFILE_CHAT_ROOM,
                    isAutoPublish,
                    isAutoSubscribeAudio,
                    isAutoSubscribeVideo);
            rtcRoom.joinRoom(token, userInfo, roomConfig);
        });
    }

    private void leaveRoom() {
        if (rtcRoom != null) {
            rtcRoom.leaveRoom();
            rtcRoom.destroy();
            rtcRoom = null;
        }
    }

    IRTCVideoEventHandler rtcVideoEventHandler = new IRTCVideoEventHandler() {
        private String previousMessage;
        private long previousTime = 0;

        @Override
        public void onSEIMessageReceived(RemoteStreamKey remoteStreamKey, ByteBuffer message) {
            super.onSEIMessageReceived(remoteStreamKey, message);
            Charset charset = Charset.defaultCharset();
            String dataString = charset.decode(message).toString();
            long currentTime = SystemClock.uptimeMillis();
            if (!TextUtils.equals(previousMessage, dataString) || (currentTime - previousTime > 1000)) {
                previousMessage = dataString;
                previousTime = currentTime;
                ToastUtil.showLongToast(SEIMessageActivity.this, "onSEIMessageReceivedï¼š" + dataString);
            }
        }
    };

    IRTCRoomEventHandler rtcRoomEventHandler = new IRTCRoomEventHandler() {
        @Override
        public void onRoomStateChanged(String roomId, String uid, int state, String extraInfo) {
            super.onRoomStateChanged(roomId, uid, state, extraInfo);
            String info = String.format(Locale.ENGLISH, "roomId:%s, uid:%s, state:%d, extraInfo:%s", roomId, uid, state, extraInfo);
            ToastUtil.showToast(SEIMessageActivity.this, info);
        }

        @Override
        public void onLeaveRoom(RTCRoomStats stats) {
            super.onLeaveRoom(stats);
            ToastUtil.showLongToast(SEIMessageActivity.this, "onLeaveRoom, stats:" + stats.toString());
        }
    };

    private void startPushMixedStreamToCDN() {
        String cdnAddr = binding.pushUrlInput.getText().toString();
        if (cdnAddr.isEmpty()) {
            ToastUtil.showToast(this, R.string.toast_cdn_url_is_empty);
            return;
        }
        String msg = binding.layoutMsgInput.getText().toString();

        mixedStreamConfig.setUserID(localUid);
        mixedStreamConfig.setRoomID(roomID);
        mixedStreamConfig.setPushURL(cdnAddr);

        MixedStreamConfig.MixedStreamLayoutConfig layoutConfig = new MixedStreamConfig.MixedStreamLayoutConfig();
        layoutConfig.setRegions(getLayoutRegions());
        layoutConfig.setBackgroundColor("#000000");
        layoutConfig.setUserConfigExtraInfo(msg);
        mixedStreamConfig.setLayout(layoutConfig);
        rtcVideo.startPushMixedStreamToCDN(CDN_TASK_ID, mixedStreamConfig, mixedStreamObserver);
    }

    private MixedStreamConfig.MixedStreamLayoutRegionConfig[] getLayoutRegions() {
        int regionWidth = mixedStreamConfig.getVideoConfig().getWidth();
        int regionHeight = mixedStreamConfig.getVideoConfig().getHeight();
        MixedStreamConfig.MixedStreamLayoutRegionConfig[] regions = new MixedStreamConfig.MixedStreamLayoutRegionConfig[1];
        MixedStreamConfig.MixedStreamLayoutRegionConfig region = new MixedStreamConfig.MixedStreamLayoutRegionConfig();
        region.setRoomID(roomID);
        region.setUserID(localUid);
        region.setLocationX(0);
        region.setLocationY(0);
        region.setWidth(regionWidth);
        region.setHeight(regionHeight);
        region.setAlpha(1);
        region.setZOrder(0);
        region.setRenderMode(MixedStreamConfig.MixedStreamRenderMode.MIXED_STREAM_RENDER_MODE_HIDDEN);
        region.setStreamType(MixedStreamConfig.MixedStreamLayoutRegionConfig.MixedStreamVideoType.MIXED_STREAM_VIDEO_TYPE_MAIN);
        region.setMediaType(MixedStreamConfig.MixedStreamMediaType.MIXED_STREAM_MEDIA_TYPE_AUDIO_AND_VIDEO);
        regions[0] = region;
        return regions;
    }

    private void updateCDNStreamConfig() {
        String cdnAddr = binding.pushUrlInput.getText().toString();
        if (cdnAddr.isEmpty()) {
            ToastUtil.showToast(this, R.string.toast_cdn_url_is_empty);
            return;
        }
        String msg = binding.layoutMsgInput.getText().toString();

        mixedStreamConfig.setPushURL(cdnAddr);

        MixedStreamConfig.MixedStreamLayoutConfig layoutConfig = new MixedStreamConfig.MixedStreamLayoutConfig();
        layoutConfig.setRegions(getLayoutRegions());
        layoutConfig.setUserConfigExtraInfo(msg);
        layoutConfig.setBackgroundColor("#000000");
        mixedStreamConfig.setLayout(layoutConfig);

        rtcVideo.updatePushMixedStreamToCDN(CDN_TASK_ID, mixedStreamConfig);
    }

    private void stopPushCDNStream() {
        rtcVideo.stopPushStreamToCDN(CDN_TASK_ID);
    }

    private void startPushCustomVideo() {
        String customMessage = binding.videoFrameMsgInput.getText().toString();
        if (TextUtils.isEmpty(customMessage)) {
            ToastUtil.showToast(this, R.string.msg_empty_sei_message);
            return;
        }

        this.customMessage = customMessage;

        if (isPushingCustomVideo) {
            Log.w(TAG, "CameraHelper already started");
            return;
        }
        isPushingCustomVideo = true;

        rtcVideo.stopVideoCapture();
        rtcVideo.setVideoSourceType(StreamIndex.STREAM_INDEX_MAIN, VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL);

        cameraHelper.bind(this);
    }

    class RTCVideoFrameConsumer implements ImageAnalysis.Analyzer {
        @Override
        public void analyze(@NonNull ImageProxy image) {
            final ImageInfo info = image.getImageInfo();
            final int width = image.getWidth();
            final int height = image.getHeight();
            final int degrees = info.getRotationDegrees();

            final int imageFormat = image.getFormat();

            assert imageFormat == PixelFormat.RGBA_8888;

            ByteBuffer data = image.getPlanes()[0].getBuffer();
            pushRGBAToRTC(data, width, height, degrees);

            image.close();
        }

        /**
         * Push RGBA to RTC
         *
         * @param source  RGBA buffer
         * @param width   image width
         * @param height  image height
         * @param degrees image rotation degrees
         */
        private void pushRGBAToRTC(ByteBuffer source, int width, int height, int degrees) {
            CpuBufferVideoFrameBuilder builder = new CpuBufferVideoFrameBuilder(VideoPixelFormat.RGBA)
                    .setWidth(width)
                    .setHeight(height)
                    .setRotation(toRotation(degrees))
                    .setTimeStampUs(System.nanoTime())
                    .setPlaneData(0, source)
                    .setPlaneStride(0, width * 4)
                    // Set Frame Custom SEI message
                    .setExternalDataInfo(ByteBuffer.wrap(customMessage.getBytes(StandardCharsets.UTF_8)));

            rtcVideo.pushExternalVideoFrame(builder.build());
        }

        private static VideoRotation toRotation(int degrees) {
            return switch (degrees) {
                case 90 -> VideoRotation.VIDEO_ROTATION_90;
                case 180 -> VideoRotation.VIDEO_ROTATION_180;
                case 270 -> VideoRotation.VIDEO_ROTATION_270;
                default -> VideoRotation.VIDEO_ROTATION_0;
            };
        }
    }

    private void stopPushCustomVideo() {
        if (isPushingCustomVideo) {
            isPushingCustomVideo = false;

            cameraHelper.unbind(this);

            rtcVideo.setVideoSourceType(StreamIndex.STREAM_INDEX_MAIN, VideoSourceType.VIDEO_SOURCE_TYPE_INTERNAL);
            rtcVideo.startVideoCapture();
        }
    }

    IMixedStreamObserver mixedStreamObserver = new IMixedStreamObserver() {
        @Override
        public boolean isSupportClientPushStream() {
            ToastUtil.showToast(SEIMessageActivity.this, "isSupportClientPushStream");
            return false;
        }

        @Override
        public void onMixingEvent(ByteRTCStreamMixingEvent eventType, String taskId, ByteRTCTranscoderErrorCode error, MixedStreamType mixType) {
            String msg = String.format("onMixingEvent, type:%s, taskId:%s, error:%s, mixType:%s", eventType.toString(), taskId, error.toString(), mixType.toString());
            Log.d(TAG, msg);
            ToastUtil.showLongToast(SEIMessageActivity.this, msg);
        }

        @Override
        public void onMixingAudioFrame(String taskId, byte[] audioFrame, int frameNum, long timeStampMs) {
            String msg = String.format(Locale.ENGLISH, "onMixingEvent, taskId:%s, frameNum:%d, timeStampMs:%d", taskId, frameNum, timeStampMs);
            Log.d(TAG, msg);
            ToastUtil.showLongToast(SEIMessageActivity.this, msg);
        }

        @Override
        public void onMixingVideoFrame(String taskId, VideoFrame videoFrame) {
            String msg = String.format("onMixingVideoFrame, taskId:%s", taskId);
            Log.d(TAG, msg);
            ToastUtil.showLongToast(SEIMessageActivity.this, msg);
        }

        @Override
        public void onMixingDataFrame(String taskId, byte[] dataFrame, long time) {
            String msg = String.format("onMixingDataFrame, taskId:%s", taskId);
            Log.d(TAG, msg);
            ToastUtil.showLongToast(SEIMessageActivity.this, msg);
        }

        @Override
        public void onCacheSyncVideoFrames(String taskId, String[] userIds, VideoFrame[] videoFrame, byte[][] dataFrame, int count) {
            String msg = String.format("onCacheSyncVideoFrames, taskId:%s", taskId);
            Log.d(TAG, msg);
            ToastUtil.showLongToast(SEIMessageActivity.this, msg);
        }
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();

        executor.shutdown();

        leaveRoom();

        if (rtcVideo != null) {
            rtcVideo.stopAudioCapture();
            rtcVideo.stopVideoCapture();
        }

        rtcVideo = null;
        RTCVideo.destroyRTCVideo();
    }
}