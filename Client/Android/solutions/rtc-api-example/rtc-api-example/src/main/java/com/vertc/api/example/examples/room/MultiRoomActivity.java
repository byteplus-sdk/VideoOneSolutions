package com.vertc.api.example.examples.room;

import android.os.Bundle;
import android.util.Log;

import com.ss.bytertc.engine.RTCRoom;
import com.ss.bytertc.engine.RTCRoomConfig;
import com.ss.bytertc.engine.RTCVideo;
import com.ss.bytertc.engine.UserInfo;
import com.ss.bytertc.engine.VideoCanvas;
import com.ss.bytertc.engine.data.RemoteStreamKey;
import com.ss.bytertc.engine.data.StreamIndex;
import com.ss.bytertc.engine.handler.IRTCRoomEventHandler;
import com.ss.bytertc.engine.handler.IRTCVideoEventHandler;
import com.ss.bytertc.engine.type.ChannelProfile;
import com.ss.bytertc.engine.type.MediaStreamType;
import com.ss.bytertc.engine.type.StreamRemoveReason;
import com.vertc.api.example.R;
import com.vertc.api.example.base.ExampleBaseActivity;
import com.vertc.api.example.base.ExampleCategory;
import com.vertc.api.example.base.annotation.ApiExample;
import com.vertc.api.example.databinding.ActivityMultiRoomBinding;
import com.vertc.api.example.utils.IMEUtils;
import com.vertc.api.example.utils.RTCHelper;
import com.vertc.api.example.utils.ToastUtil;

import java.util.Locale;

/**
 * <pre>
 * Function name: BytePlusRTC multi-room
 * Function brief: Used to allow the same user to join multiple RTC rooms, enabling them to listen to or watch audio and video in different rooms at the same time, and publish their own media stream in one of the rooms.
 * Notes:
 *   1. For demonstration purposes, all tokens for the functionalities are generated by the client-side TokenGenerator class. However, please adjust accordingly based on the specific circumstances when integrating in a real environment.
 *   2. This demo only showcases three video windows. The top row displays the locally captured video, while the second row shows the video feed from remote users in room1 and room2 respectively.
 * Reference document: https://docs.byteplus.com/en/docs/byteplus-rtc/docs-196844
 * </pre>
 */
@ApiExample(title = "Multi-Room", category = ExampleCategory.ROOM, order = 1)
public class MultiRoomActivity extends ExampleBaseActivity {

    private static final String TAG = "MultiRoomActivity";

    ActivityMultiRoomBinding binding;

    RTCVideo rtcVideo;

    RTCRoom rtcRoom1;
    RTCRoom rtcRoom2;
    private String roomID1;
    private String roomID2;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = ActivityMultiRoomBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        binding.getRoot().setOnClickListener(IMEUtils::closeIME);

        initUI(binding);

        rtcVideo = RTCHelper.createRTCVideo(this, videoEventHandler);
        setLocalRenderView();
        rtcVideo.startAudioCapture();
        rtcVideo.startVideoCapture();
    }

    private void initUI(ActivityMultiRoomBinding binding) {
        binding.btnJoinRoom1.setOnClickListener(v -> {
            if (v.isSelected()) {
                leaveFirstRoom();
                v.setSelected(false);
                binding.btnJoinRoom1.setText(R.string.button_join_room);
            } else {
                String roomId = binding.room1Input.getText().toString();
                if (!RTCHelper.checkValid(roomId)) {
                    ToastUtil.showToast(this, R.string.toast_check_valid_false);
                    return;
                }
                joinFirstRoom(roomId);
                v.setSelected(true);
                binding.btnJoinRoom1.setText(R.string.button_leave_room);
            }
        });
        binding.btnJoinRoom2.setOnClickListener(v -> {
            if (v.isSelected()) {
                leaveSecondRoom();
                v.setSelected(false);
                binding.btnJoinRoom2.setText(R.string.button_join_room);
            } else {
                String roomId = binding.room2Input.getText().toString();
                if (!RTCHelper.checkValid(roomId)) {
                    ToastUtil.showToast(this, R.string.toast_check_valid_false);
                }
                joinSecondRoom(roomId);
                v.setSelected(true);
                binding.btnJoinRoom2.setText(R.string.button_leave_room);
            }
        });
    }

    private void setLocalRenderView() {
        VideoCanvas videoCanvas = new VideoCanvas();
        videoCanvas.renderView = binding.localView;
        videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
        rtcVideo.setLocalVideoCanvas(StreamIndex.STREAM_INDEX_MAIN, videoCanvas);
    }

    public void joinFirstRoom(String roomID) {
        if (!RTCHelper.checkValid(roomID)) {
            ToastUtil.showToast(this, R.string.toast_check_valid_false);
            return;
        }

        requestRoomToken(roomID, localUid, token -> {
            this.roomID1 = roomID;
            rtcRoom1 = rtcVideo.createRTCRoom(roomID);
            rtcRoom1.setRTCRoomEventHandler(firstRoomEventHandler);

            UserInfo userInfo = new UserInfo(localUid, "");
            boolean isAutoPublish = true;
            boolean isAutoSubscribeAudio = true;
            boolean isAutoSubscribeVideo = true;
            RTCRoomConfig roomConfig = new RTCRoomConfig(
                    ChannelProfile.CHANNEL_PROFILE_CHAT_ROOM,
                    isAutoPublish,
                    isAutoSubscribeAudio,
                    isAutoSubscribeVideo);
            rtcRoom1.joinRoom(token, userInfo, roomConfig);
        });
    }

    public void joinSecondRoom(String roomID) {
        if (!RTCHelper.checkValid(roomID)) {
            ToastUtil.showToast(this, R.string.toast_check_valid_false);
            return;
        }

        requestRoomToken(roomID, localUid, token -> {
            this.roomID2 = roomID;
            rtcRoom2 = rtcVideo.createRTCRoom(roomID);
            rtcRoom2.setRTCRoomEventHandler(secondRoomEventHandler);
            UserInfo userInfo = new UserInfo(localUid, "");
            // Not publish stream to room2
            boolean isAutoPublish = false;
            boolean isAutoSubscribeAudio = true;
            boolean isAutoSubscribeVideo = true;
            RTCRoomConfig roomConfig = new RTCRoomConfig(
                    ChannelProfile.CHANNEL_PROFILE_CHAT_ROOM,
                    isAutoPublish, isAutoSubscribeAudio,
                    isAutoSubscribeVideo);
            rtcRoom2.joinRoom(token, userInfo, roomConfig);
        });
    }

    public void leaveFirstRoom() {
        if (rtcRoom1 != null) {
            rtcRoom1.leaveRoom();
            rtcRoom1.destroy();
            rtcRoom1 = null;
        }
    }

    public void leaveSecondRoom() {
        if (rtcRoom2 != null) {
            rtcRoom2.leaveRoom();
            rtcRoom2.destroy();
            rtcRoom2 = null;
        }
    }

    private final IRTCRoomEventHandler firstRoomEventHandler = new IRTCRoomEventHandler() {
        @Override
        public void onRoomStateChanged(String roomId, String uid, int state, String extraInfo) {
            super.onRoomStateChanged(roomId, uid, state, extraInfo);
            String info = String.format(Locale.ENGLISH, "onRoomStateChanged,roomId:%s, uid:%s, state:%d, extraInfo:%s", roomId, uid, state, extraInfo);
            Log.i(TAG, "room1: " + info);
            runOnUiThread(() -> {
                if (state == 0) {
                    binding.localUserName.setText(uid);
                }
                ToastUtil.showLongToast(MultiRoomActivity.this, info);
            });
        }

        @Override
        public void onUserPublishStream(String uid, MediaStreamType type) {
            super.onUserPublishStream(uid, type);
            runOnUiThread(() -> {
                RemoteStreamKey remoteStreamKey = new RemoteStreamKey(roomID1, uid, StreamIndex.STREAM_INDEX_MAIN);
                VideoCanvas videoCanvas = new VideoCanvas();
                videoCanvas.renderView = binding.remoteView1;
                videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
                rtcVideo.setRemoteVideoCanvas(remoteStreamKey, videoCanvas);

                binding.remoteUserName1.setText(uid);
            });
        }

        @Override
        public void onUserUnpublishStream(String uid, MediaStreamType type, StreamRemoveReason reason) {
            super.onUserUnpublishStream(uid, type, reason);
            runOnUiThread(() -> {
                RemoteStreamKey remoteStreamKey = new RemoteStreamKey(roomID1, uid, StreamIndex.STREAM_INDEX_MAIN);
                rtcVideo.setRemoteVideoCanvas(remoteStreamKey, null);

                binding.remoteUserName1.setText("");
            });
        }

        @Override
        public void onUserLeave(String uid, int reason) {
            super.onUserLeave(uid, reason);
            String info = String.format("onUserLeave, roomId:%s, uid:%s, reason:%s", roomID1, uid, reason + "");
            ToastUtil.showLongToast(MultiRoomActivity.this, info);
        }
    };

    private final IRTCRoomEventHandler secondRoomEventHandler = new IRTCRoomEventHandler() {
        @Override
        public void onRoomStateChanged(String roomId, String uid, int state, String extraInfo) {
            super.onRoomStateChanged(roomId, uid, state, extraInfo);
            String info = String.format(Locale.ENGLISH, "onRoomStateChanged, roomId:%s, uid:%s, state:%d, extraInfo:%s", roomId, uid, state, extraInfo);
            runOnUiThread(() -> {
                ToastUtil.showLongToast(MultiRoomActivity.this, info);
            });
            Log.i(TAG, "room2: " + info);
        }

        @Override
        public void onUserPublishStream(String uid, MediaStreamType type) {
            super.onUserPublishStream(uid, type);
            runOnUiThread(() -> {
                RemoteStreamKey remoteStreamKey = new RemoteStreamKey(roomID2, uid, StreamIndex.STREAM_INDEX_MAIN);
                VideoCanvas videoCanvas = new VideoCanvas();
                videoCanvas.renderView = binding.remoteView2;
                videoCanvas.renderMode = VideoCanvas.RENDER_MODE_HIDDEN;
                rtcVideo.setRemoteVideoCanvas(remoteStreamKey, videoCanvas);

                binding.remoteUserName2.setText(uid);
            });
        }

        @Override
        public void onUserUnpublishStream(String uid, MediaStreamType type, StreamRemoveReason reason) {
            super.onUserUnpublishStream(uid, type, reason);
            runOnUiThread(() -> {
                RemoteStreamKey remoteStreamKey = new RemoteStreamKey(roomID2, uid, StreamIndex.STREAM_INDEX_MAIN);
                rtcVideo.setRemoteVideoCanvas(remoteStreamKey, null);

                binding.remoteUserName2.setText("");
            });
        }

        @Override
        public void onUserLeave(String uid, int reason) {
            super.onUserLeave(uid, reason);
            String info = String.format("onUserLeave, roomId:%s, uid:%s, reason:%s", roomID2, uid, reason + "");
            ToastUtil.showLongToast(MultiRoomActivity.this, info);
        }
    };

    private final IRTCVideoEventHandler videoEventHandler = new IRTCVideoEventHandler() {
        @Override
        public void onWarning(int warn) {
            super.onWarning(warn);
            runOnUiThread(() -> ToastUtil.showLongToast(MultiRoomActivity.this, "onWarning:" + warn));

        }

        @Override
        public void onError(int err) {
            super.onError(err);
            runOnUiThread(() -> ToastUtil.showLongToast(MultiRoomActivity.this, "onError:" + err));
        }
    };

    @Override
    protected void onDestroy() {
        super.onDestroy();
        leaveFirstRoom();
        leaveSecondRoom();
        if (rtcVideo != null) {
            rtcVideo.stopAudioCapture();
            rtcVideo.stopVideoCapture();
        }
        RTCVideo.destroyRTCVideo();
        rtcVideo = null;
    }
}